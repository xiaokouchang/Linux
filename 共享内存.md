@[TOC](文 章 目 录)
>💻作 者 简 介：曾 与 你 一 样 迷 茫，现 以 经 验 助 你 入 门 Linux。
>💡个 人 主 页：[@笑口常开xpr 的 个 人 主 页](https://blog.csdn.net/2301_78847073?spm=1000.2115.3001.5343)
>📚系 列 专 栏：[Linux 探 索 之 旅：从 命 令 行 到 系 统 内 核](https://blog.csdn.net/2301_78847073/category_13024932.html)
>✨代 码 趣 语：静 态 库 是 装 满 工 具 的 箱 子，编 译 时 全 塞 程 序，方 便 但 沉；动 态 库 是 共 享 架，记 位 置，没 工 具 就 卡 壳。
>💪代 码 千 行，始 于 坚 持，每 日 敲 码，进 阶 编 程 之 路。
>📦gitee 链 接：[gitee](https://gitee.com/xiaokouchangkai123)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fc8d52ed792a4cec88378dd286938beb.gif)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在 Linux C/C++ 开 发 中，库 是 代 码 复 用 和 工 程 化 的 核 心。不 少 开 发 者 会 遇 到 源 码 泄 露、编 译 “找 不 到 头 文 件 / 库”、动 态 库 运 行 加 载 失 败 等 问 题，本 质 是 对 库 的 流 程 不 熟 悉。本 文 从 背 景 切 入，先 讲 静 态 库 的 原 理、制 作 与 使 用，再 讲 动 态 库 的 实 战 技 巧，帮 你 掌 握 库 的 全 流 程 应 用。
***
# 共 享 内 存
## 直 接 原 理
进 程 间 通 信 的 本 质 是 先 让 不 同 的 进 程 看 到 同 一 份 资 源。共 享 内 存 区 是 最 快 的 IPC 形 式。一 旦 这 样 的 内 存 映 射 到 共 享 它 的 进 程 的 地 址 空 间，这 些 进 程 间 数 据 传 递 不 再 涉 及 到 内 核，进 程 不 再 通 过 执 行 进 入 内 核 的 系 统 调 用 来 传 递 彼 此 的 数 据。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/713676ec31a24f5a960aeec1872dc27b.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fa28777d109b43269774001caec723e0.png)
**shmget**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/60550af6156c4cb7833282cc867ce47a.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/35695be8212b4600bca2c28d4d9c6eb6.png)
**IPC_CREAT（单 独）**：如 果 申 请 的 共 享 内 存 不 存 在，就 创 建，存 在 就 获 取 并 返 回。

**IPC_CREAT | IPC_EXCL**：如 果 申 请 的 共 享 内 存 不 存 在，就 创 建，存 在 就 出 错 并 返 回。如 果 申 请 成 功 了 一 个 共 享 内 存，这 个 共 享 内 存 一 定 是 一 个 新 的。IPC_EXCL 不 单 独 使 用。

**Key**
1. key 是 一 个 数 字，这 个 数 字 是 几 不 重 要，关 键 在 于 它 必 须 在 内 存 中 具 有 唯 一 性，能 够 让 不 同 的 进 程 进 行 唯 一 性 标 识，用 来 确 定 共 享 内 存 是 否 存 在。
2. 第 1 个 进 程 可 以 通 过 key 创 建 共 享 内 存，第 二 个 以 后 的 进 程，只 要 拿 着 同 一 个 key 就 可 以 和 第 一 个 进 程 看 到 同 一 个 共 享 内 存。
3. 已 经 创 建 的 共 享 内 存，key 在 共 享 内 存 的 描 述 对 象 中。
4. 第 一 次 创 建 的 时 候，必 须 要 有 一 个 key 了，
5. key 类 似 于 命 名 管 道 中 的 路 径 + 文 件 的 操 作。

**ftok**
返 回 key。ftok 是 一 套 算 法，对 pathname 和 proj_id 进 行 了 数 值 计 算 即 可。pathname 和 proj_id 由 用 户 约 定 的。key 也 可 以 由 操 作 系 统 生 成，但 是 操 作 系 统 不 知 道 哪 两 个 进 程 要 进 行 通 信，无 法 进 行 传 递。


![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/72d49e4406b84e6f910b16fdd22c9a44.png)
**log.hpp**
```javascript
#pragma once

#include <iostream>
#include <time.h>
#include <stdarg.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
using namespace std;
#define SIZE 1024
//日志危险等级
#define Info 0
#define Debug 1
#define Warning 2
#define Error 3
#define Fatal 4

//日志显示
#define Screen 1
#define Onefile 2
#define Classfile 3
//日志存放位置
#define LogFile "log.txt"

class Log
{
public:
    Log()
    {
        printMethod = Screen;
        path = "./log/";
    }
    void Enable(int method)
    {
        printMethod = method;
    }
    std::string levelToString(int level)
    {
        switch (level)
        {
        case Info:
            return "Info";
        case Debug:
            return "Debug";
        case Warning:
            return "Warning";
        case Error:
            return "Error";
        case Fatal:
            return "Fatal";
        default:
            return "None";
        }
    }

    // void logmessage(int level, const char *format, ...)
    // {
    //     time_t t = time(nullptr);
    //     struct tm *ctime = localtime(&t);
    //     char leftbuffer[SIZE];
    //     snprintf(leftbuffer, sizeof(leftbuffer), "[%s][%d-%d-%d %d:%d:%d]", levelToString(level).c_str(),
    //              ctime->tm_year + 1900, ctime->tm_mon + 1, ctime->tm_mday,
    //              ctime->tm_hour, ctime->tm_min, ctime->tm_sec);

    //     va_list s;
    //     va_start(s, format);
    //     char rightbuffer[SIZE];
    //     vsnprintf(rightbuffer, sizeof(rightbuffer), format, s);
    //     // va_end(s);

    //     // 格式：默认部分+自定义部分
    //     char logtxt[SIZE * 2];
    //     snprintf(logtxt, sizeof(logtxt), "%s %s\n", leftbuffer, rightbuffer);

    //     // printf("%s", logtxt); // 暂时打印
    //     printLog(level, logtxt);
    // }
    void printLog(int level, const std::string &logtxt)
    {
        switch (printMethod)
        {
        case Screen:
            std::cout << logtxt << std::endl;
            break;
        case Onefile:
            printOneFile(LogFile, logtxt);
            break;
        case Classfile:
            printClassFile(level, logtxt);
            break;
        default:
            break;
        }
    }
    void printOneFile(const std::string &logname, const std::string &logtxt)
    {
        std::string _logname = path + logname;
        int fd = open(_logname.c_str(), O_WRONLY | O_CREAT | O_APPEND, 0666); // "log.txt"
        if (fd < 0)
            return;
        write(fd, logtxt.c_str(), logtxt.size());
        close(fd);
    }
    void printClassFile(int level, const std::string &logtxt)
    {
        std::string filename = LogFile;
        filename += ".";
        filename += levelToString(level); // "log.txt.Debug/Warning/Fatal"
        printOneFile(filename, logtxt);
    }

    ~Log()
    {
    }
    void operator()(int level, const char *format, ...)
    {
        time_t t = time(nullptr);
        struct tm *ctime = localtime(&t);
        char leftbuffer[SIZE];
        snprintf(leftbuffer, sizeof(leftbuffer), "[%s][%d-%d-%d %d:%d:%d]", levelToString(level).c_str(),
                 ctime->tm_year + 1900, ctime->tm_mon + 1, ctime->tm_mday,
                 ctime->tm_hour, ctime->tm_min, ctime->tm_sec);

        va_list s;
        va_start(s, format);
        char rightbuffer[SIZE];
        vsnprintf(rightbuffer, sizeof(rightbuffer), format, s);
        va_end(s);

        // 格式：默认部分+自定义部分
        char logtxt[SIZE * 2];
        snprintf(logtxt, sizeof(logtxt), "%s %s", leftbuffer, rightbuffer);

        // printf("%s", logtxt); // 暂时打印
        printLog(level, logtxt);
    }

private:
    int printMethod;
    std::string path;
};
//可变参数必须要有至少一个具体的参数
int sum(int n,...)
{
    //va_list和va_start都是宏
    va_list s;//char*
    va_start(s, n);//实例化是从右向左进行实例化的,s是最后一个被实例化的,s指向可变部分
    int sum = 0;
    while(n)
    {
        sum += va_arg(s,int);//int能被传递证明了va_arg是宏,因为C/C++中类型是不能用于可变参数传递的
        // printf("hello %d, hello %s, hello %c, hello %d,", 1, "hello", 'c', 123);
        n--;
    }
    va_end(s); // s = NULL;
    return sum;
}
```
**processa.cc**
```javascript
#include "share.hpp"
int main()
{
    int shmid = GetShareMemory();
    sleep(20);
    log(Debug,"process quit...");
    return 0;
}
```
**makefile**
```javascript
.PHONY:all
all:processa processb

processa:processa.cc
	g++ -o $@ $^ -g -std=c++11
processb:processb.cc
	g++ -o $@ $^ -g -std=c++11

.PHONY:clean
clean:
	rm -f processa processb

```
**share.hpp**
```javascript
#ifndef __SHARE_HPP__
#define __SHARE_HPP__
#include <iostream>
#include <string> 
#include <cstdlib> 
#include <sys/ipc.h>
#include <sys/shm.h>
#include <cstring>
#include <sys/types.h>
#include "log.hpp"

using namespace std;

const int size = 4096; //共享内存大小
const string pathname = "/home/xpr"; //pathname
const int proj_id = 0x6666; //proj_id
Log log;
key_t GetKey()
{
    key_t k = ftok(pathname.c_str(),proj_id);
    if(k < 0)
    {
        log(Fatal,"ftok error: %s",strerror(errno));
        exit(1);
    }
    log(Info,"ftok success,key is: %d",k);
    return k;
}
//创建
int GetShareMemory()
{
    key_t k = GetKey();
    // int shmid = shmget(k,size,IPC_CREAT|IPC_EXCL);
    int shmid = shmget(k,size,IPC_CREAT);
    if(shmid < 0)
    {
        log(Fatal,"create share memory error: %s",strerror(errno));
        exit(1);
    }
    log(Info,"create share memory success,shmid: %d",shmid);
    return shmid;
}
#endif
```

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7b3bd3cf21cd414fba06d5d952ff4bba.png)
**ipcs -m**
查 看 共 享 内 存。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6595ddee1ef847ff8c18a2f2168bf1c1.png)
**ipcrm -m + shmid**
关 闭 共 享 内 存。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ae1886761b94465f8f4d8b0a4dcdc54e.png)

程 序 已 经 结 束，共 享 内 存 仍 然 存 在，操 作 系 统 没 有 关 闭 共 享 内 存。共 享 内 存 的 生 命 周 期 是 随 内 核 的。用 户 不 主 动 关 闭，共 享 内 存 会 一 直 存 在。除 非 内 核 重 启 或 者 用 户 释 放。如 果 没 有 关 闭，就 会 发 生 内 存 泄 露。
## key vs shmid
key 用 来 在 操 作 系 统（内 核） 内 标 识 唯 一 性。
shmid 只 在 进 程 内（用 户 层），用 来 表 示 资 源 的 唯 一 性。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/332df6c4d34e410785f3136f12f92a68.png)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5ca4aadf8a9741e9ae041004ed79d197.png)
## 权 限
可 以 在 创 建 共 享 内 存 时 设 置 权 限。
```javascript
int shmid = shmget(k,size,IPC_CREAT|IPC_EXCL|0666);
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/920e49cbc14b44e99462a1b5896d4b50.png)
## 大 小
共 享 内 存 的 大 小 建 议 设 置 为 4096（4KB）的 整 数 倍。如 果 设 置 的 是 4097，实 际 上 操 作 系 统 设 置 的 是 4096 * 2 的 大 小，但 事 实 上 只 能 使 用 4097，多 余 的 不 能 使 用。
```javascript
const int size = 4097; //共享内存大小
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9659eac32c6a428eacebe2a0524ecda7.png)
## 关 联
**shmat**
挂 接 在 共 享 区，返 回 共 享 内 存 的 起 始 地 址。
**shaddr**：挂 接 在 共 享 区，由 操 作 系 统 决 定 挂 接 在 哪 里，设 为 NULL。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6be4516e3b0f468b9dafd9a470cdbe05.png)
**processa.cc**
```javascript
#include "share.hpp"
int main()
{
    sleep(3);
    int shmid = CreateShm();//创建共享内存
    log(Debug,"create shm done");
    sleep(5);
    char* shmaddr = (char*)shmat(shmid,nullptr,0);//挂接在共享区
    log(Debug,"attach shm done");
    sleep(5);
    return 0;
}
```
如 下 图 所 示，左 边 窗 口 通 过 运 行 程 序 来 创 建 共 享 内 存，右 边 窗 口 通 过 这 句 指 令 来 监 视 共 享 内 存。
```javascript
while :;do ipcs -m | head -4 && ipcs -m | grep xpr;sleep 1;done
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cced254b0942410ea0c220ac16e4228e.png)
总 共 分 为 3 种 情 况，挂 接 共 享 内 存 之 前，共 享 内 存 的 关 联 数 为 0，挂 接 之 后，关 联 数 变 为 1，最 后 程 序 结 束，PCB 地 址 空 间 页 表 全 部 释 放，关 联 数 变 为 0。
***
**shmadt**
 程 序 去 除 关 联，参 数 是 **shmat** 返 回 的 虚 拟 地 址（起 始 地 址）。共 享 内 存 是 连 续 的，有 属 性 记 录 着 共 享 内 存 的 大 小，才 能 通 过 起 始 地 址 和 大 小 来 释 放 共 享 内 存。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4a35baed92a74fa8a0be223389265e02.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/eddcabe917dd41e0af4e75fab10b4736.png)
```javascript
#include "share.hpp"
int main()
{
    sleep(3);
    int shmid = CreateShm();//创建共享内存
    log(Debug,"create shm done");
    sleep(5);
    char* shmaddr = (char*)shmat(shmid,nullptr,0);//挂接在共享区
    log(Debug,"attach shm done,shmaddr:0x%x",shmaddr);
    sleep(5);
    shmdt(shmaddr);
    sleep(5);
    return 0;
}
```
***
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5d364bb861064a5fb45661d33d7c7ca7.png)
**shmctl**
释 放 共 享 内 存。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/795174b4ab8a46e9911800604f07de24.png)

# 三、总 结
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本 文 覆 盖 了 静 态 库（.o 打 包、Makefile 构 建、-I/-L/-l 链 接）与 动 态 库（-fPIC/-shared 编 译、4 种 加 载 问 题 解 决 方 案）的 核 心 内 容。静 态 库 嵌 入 程 序、独 立 但 体 积 大，动 态 库 共 享 模 块、轻 量 但 需 依 赖 系 统，需 按 需 选 择。后 续 可 尝 试 封 装 通 用 模 块 为 库，或 研 究 版 本 管 理，进 一 步 提 升 开 发 效 率。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d4027f37013e40408f63251e2f86090c.gif)