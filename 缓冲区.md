# 文 件 描 述 符
## 重 新 认 识 缓 冲 区
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    const char* fstr = "hello fwrite\n";
    const char* str = "hello write\n";
    //C
    printf("hello printf\n");            //stdout ---> 1
    fprintf(stdout, "hello fprintf\n");  //stdout ---> 1
    fwrite(fstr,strlen(fstr),1,stdout);  //stdout ---> 1
    //close(1);
    //操作系统提供的系统接口
    write(1,str,strlen(str));            //stdout ---> 1
    fork();
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/99bdbec16f0143d78157c284e2897a2f.png)
代 码 的 结 果 为 直 接 输 出 时 显 示 正 常 输 出，输 出 到 文 件 中 时 C 语 言 的 接 口 输 出 了 2 次，系 统 调 用 的 函 数 输 出 了 1 次。

**原 因**：向 显 示 器 输 出 为 行 缓 冲 方 式 会 依 次 输 出 到 显 示 器 中。当 向 文 件 中 输 出 时，缓 冲 方 式 由 行 缓 冲 变 成 了 全 缓 冲。即 遇 到 `\n`，不 在 刷 新，而 是 等 缓 冲 区 被 写 满 才 刷 新。
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    const char* fstr = "hello fwrite\n";
    const char* str = "hello write\n";
    printf("hello printf\n");              //stdout ---> 1
    sleep(2);
    fprintf(stdout, "hello fprintf\n");    //stdout ---> 1
    sleep(2);
    fwrite(fstr,strlen(fstr),1,stdout);  //stdout ---> 1
    sleep(2);
    write(1,str,strlen(str));            //stdout ---> 1
    sleep(5);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6c12e1122a534f5d9a30c3b9ec599671.png)
前 6 秒 时 C 接 口 的 函 数 被 存 储 在 C 语 言 的 缓 冲 区 中，write 函 数 通 过 缓 冲 区 直 接 写 入 文 件 中，当 进 程 结 束 时 会 刷 新 缓 冲 区 将 数 据 放 入 文 件 中。
***
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    const char* fstr = "hello fwrite\n";
    const char* str = "hello write\n";
    //C
    printf("hello printf\n");            //stdout ---> 1
    fprintf(stdout, "hello fprintf\n");  //stdout ---> 1
    fwrite(fstr,strlen(fstr),1,stdout);  //stdout ---> 1
    close(1);
    //操作系统提供的系统接口
    write(1,str,strlen(str));            //stdout ---> 1
    fork();
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/72fa453898f44a75a48847b96a5018b7.png)
和 第 1 次 代 码 的 结 果 不 同，添 加 close 后，C 语 言 的 接 口 输 出 了 1 次，系 统 调 用 的 接 口 没 有 输 出。
***
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    const char* fstr = "hello fwrite";
    printf("hello printf");            //stdout ---> 1
    fprintf(stdout, "hello fprintf");  //stdout ---> 1
    fwrite(fstr,strlen(fstr),1,stdout);  //stdout ---> 1
    close(1);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/558f323056f14d60a571db3b3e0429fb.png)
如 果 去 掉 `\n`，代 码 没 有 输 出。
***
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    const char* str = "hello fwrite";
    write(1,str,strlen(str));            //stdout ---> 1
    close(1);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/82465fa939164021b78dd2d2462a385b.png)
代 码 没 有 `\n`，和 C 语 言 的 接 口 不 同，系 统 调 用 的 接 口 可 以 输 出。
***
### 总 结
1. 缓 冲 区 一 定 不 在 操 作 系 统 内 部，不 是 系 统 级 别 的 缓 冲 区。write 可 以 输 出 是 因 为 write 直 接 将 字 符 串 写 入 了 缓 冲 区 中，close 对 显 示 没 有 影 响。

2. C 语 言 会 提 供 一 个 用 户 级 缓 冲 区，C 语 言 的 接 口 函 数 传 递 的 数 据 实 际 上 储 存 在 C 语 言 提 供 的 用 户 级 缓 存 区 中，当 调 用  `\n`、`fclose` 等 可 以 刷 新 缓 冲 区 时，才 会 刷 新 C 语 言 提 供 的 缓 冲 区，并 调 用 write 函 数，将 数 据 写 入 操 作 系 统 中。

3. C 语 言 的 文 件 操 作 绕 不 开 FILE，FILE 中 包 含 文 件 描 述 符 fd，FILE 里 面 还 有 对 应 打 开 文 件 的 缓 冲 区 字 段。这 个 FILE 对 象 属 于 用 户，语 言 都 属 于 用 户 层。

4. 显 示 器 的 文 件 刷 新 方 案 是 行 刷 新，所 以 在 printf 执 行 完 成 后 就 会 立 即 遇 到 `\n` 的 时 候，将 数 据 进 行 刷 新。刷 新 的 本 质 是 将 数 据 通 过 1 + write 通 过 write 接 口 写 入 到 内 核 中。

5. 目 前 我 们 认 为，只 要 将 数 据 刷 新 进 入 了 内 核 中，数 据 就 会 被 刷 新 进 入 硬 件 中。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2f381bf0acfa4ade81c3ffe700a3c4f1.png)
***
## exit 和 _exit
[exit 和 _exit](https://blog.csdn.net/2301_78847073/article/details/150864685?spm=1001.2014.3001.5501)

exit 是 C 语 言 的 接 口，退 出 时 会 刷 新 C 语 言 提 供 的 缓 冲 区，然 后 调 用 _exit 退 出，_exit 是 系 统 调 用，直 接 释 放 进 程 不 会 对 数 据 进 行 刷 新。
***
## 缓 冲 区 的 刷 新 问 题
操 作 系 统 会 维 护 缓 冲 区。
### 无 缓 冲
无 缓 冲 区 是 一 种 写 透 模 式，不 要 在 缓 冲 区 中 做 出 各 种 数 据 残 留，直 接 刷 新，不 能 等 待，没 有 进 行 各 种 刷 新 策 略。
### 行 缓 冲
不 刷 新 直 到 遇 到 `\n` 才 会 刷 新。默 认 向 显 示 器 输 出 采 用 行 刷 新 是 因 为 显 示 器 是 给 人 看 的，人 每 次 看 数 据 符 合 每 次 看 一 行 的 习 惯，需 要 尽 可 能 快 的 把 数 据 刷 新 出 来。
### 全 缓 冲
缓 冲 区 满 了 才 会 刷 新 缓 冲 区。在 向 普 通 文 件 写 入 时 为 了 提 高 效 率 刷 新 时 不 需 要 实 时 观 看 所 以 采 用 全 缓 冲。

根 据 这 3 种 情 况 来 决 定 什 么 时 候 调 用 write 接 口 的 问 题。fflush 的 底 层 会 封 装 write。
***
## 进 程 退 出
进 程 退 出 时 也 会 刷 新 缓 冲 区。
**示 例 1**
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    printf("hello world");
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ae9e51e46aab42a284f100d42eaf3223.png)
**示 例 2**
```javascript
#include <stdio.h>
#include <string.h>
#include <unistd.h>
int main()
{
    printf("hello world");
    close(1);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/01254efa4a2a473180cc129313c6f42d.png)
printf("hello world"); 若 未 包 含 换 行 符 `\n` 且 程 序 未 结 束 或 未 手 动 刷 新，数 据 会 暂 时 留 在 缓 冲 区 中，不 会 立 即 显 示 在 终 端 上。当 使 用 close(1) 后，文 件 描 述 符 被 关 掉，会 导 致 缓 冲 区 中 的 数 据未 来 得 及 刷 新 就 丢 失，最 终 无 法 在 显 示 器 上 显 示。
***
## C 语 言 提 供 缓 冲 区
1. 解 决 效 率 问 题，硬 件 设 备 的 读 写 速 度 远 慢 于 CPU 和 内 存 的 处 理 速 度。缓 冲 区 用 于 临 时 存 储 待 输 出 或 待 读 取 的 数 据。程 序 先 将 数 据 写 入 缓 冲 区，待 缓 冲 区 满、触 发 特 定 条 件 或 程 序 结 束 时，再 一 次 性 将 缓 冲 区 数 据 写 入 硬 件 设 备。这 大 幅 减 少 了 硬 件   I/O 的 次 数，从 而 提 升 整 体 效 率。
2. 标 准 I/O 库 通 过 缓 冲 区 批 量 处 理 数 据，将 多 次 小 的 I/O 请 求 合 并 为 一 次 大 的 请 求，从 而 减 少 系 统 调 用 的 次 数，降 低 开 销。
3. 优 化 用 户 交 互 体 验。数 据 暂 存 在 缓 冲 区，直 到 遇 到 换 行 符 \n 才 刷 新 到 屏 幕。这 种 设 计 符 合 人 类 阅 读 习 惯，用 户 更 希 望 看 到 完 整 的 一 行 内 容，而 非 字 符 逐 个 零 散 显 示。