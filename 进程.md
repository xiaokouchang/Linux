# 管 理 进 程
## kill
`kill -9 PID`
杀 死（终 止）进 程。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c7c40c0c44ad449da8797b01a9f97fd6.png)
`ps 的 本 质 是 遍 历 链 表，然 后 得 到 所 有 进 程 的 相 关 信 息。`
## 系 统 调 用 接 口 
### getpid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获 得 进 程 的 标 识 符。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ea62bb2635f84dd1b0377687e3561d55.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2ec92113680248a2b63247e0f1b7f1b4.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使 用 `while :;do ps ajx | head -1 && ps ajx | grep test_debug;echo "--------------------------------------------------------------------------";sleep 1;done` 这 条 指 令 可 以 不 断 获 取 进 程 的 运 行 情 况。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/27c00ac5fed642828e5c6a457c246079.png)
### 父 进 程 - - - PPID
`getppid`

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PPID 就 是 子 进 程 用 来 记 录 父 进 程 的 唯 一 标 识 符，`getppid` 可 以 得 到 父 进 程 的 标 识 符。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e73f9b12e1bc4c12906ea586255895ff.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1a9ef7fac7e54466931b2e82499eae30.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4b713b84f9ab469a858afda459b98214.png)
***
### bash
[命 令 行 解 释 器](https://blog.csdn.net/2301_78847073/article/details/144883662?spm=1001.2014.3001.5501)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运 行 进 程 时，命 令 行 解 释 器 会 将 指 令 解 释 成 bash 的 子 进 程，由 子 进 程 执 行 对 应 的 命 令，进 程 出 问 题 不 影 响 对 应 的 bash 进 程。每 一 条 指 令 的 运 行 都 属 于 bash 的 子 进 程。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/da76968c07cc4ae68591233a06c4ea7f.png)
## 通 过 系 统 调 用 创 建 进 程
### fork
创 建 进 程
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/11d6fac3f7bc475b9e558f6da6a0442f.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d78e337404f5439f86fe63f7426918b2.png)
***
`没 有 fork`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/189f56917c2d4b62a603b7c56124cd62.png)
`有 fork`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7bf3e8715ce44f1ba6f389f0019028f8.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由 这 两 张 图 片 不 难 可 以 看 出，`fork` 后 面 的 代 码 被 执 行 了 2 次。因 为 fork 之 前 是 1 个 进 程，fork 之 后 是 2 个 进 程。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a1c6d7d4ba7f470c9ce6f1a42fd42653.png)
`fork 给 父 进 程 返 回 PID 为 子 进 程 返 回 0`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/411ffa20372f499494f97a388703c041.png)
<font color=orange>结 论</font>
1. fork > 0 和 fork = 0 同 时 存 在。
2. 父 子 关 系 成 立。
3. fork 之 后 的 代 码 是 2 个 进 程。这 里 存 在 2 个 进 程。
### 创 建 进 程 的 方 式
1. `./ 运 行 程 序` - - - 指 令 级 别 创 建 进 程
2. `fork` - - - 代 码 层 面 创 建 进 程。
### 创 建 子 进 程 的 步 骤
1. 创 建 子 进 程 PCB。
2. 填 充 PCB 对 应 的 内 容。
3. 让 子 进 程 和 父 进 程 指 向 同 样 的 代码
4. 父 子 进 程 都 有 独 立 的 task_struct，可 以 被 CPU 调 度 运 行 了。
### 四 个 问 题
1. 为 什 么 fork 要 给 子 进 程 返 回 0，给 父 进 程 返 回 子 进 程 pid？
`（1）为 了 让 fork 之 后 通 过 if 来 执 行 不 同 的 代 码 片 段。`
`（2）返 回 不 同 的 返 回 值，是 为 了 区 分 让 不 同 的 执 行 流 执 行 不 同 的 代 码 块。`
`（3）fork 之 后 的 父 子 进 程 代 码 共 享。原 因 是 因 为 父 进 程 指 向 的 代 码 和 数 据，子 进 程 此 时 没 有 执 向 代 码，子 进 程 只 能 指 向 和 父 进 程 一 样 的 代 码 和 数 据。`
<font color=orange>原 因：1 个 父 进 程 有 多 个 子 进 程，但 多 个 父 进 程 只 有 1 个 子 进 程，为 了 明 确 父 进 程 要 控 制 哪 一 个 子 进 程。</font>
2. 一 个 函 数 是 如 何 做 到 返 回 2 次 的 ？如 何 理 解？
（1）`进 程 = 内 核 数 据 结 构 + 代 码 和 数 据`
（2）创 建 子 进 程 的 本 质 是 进 程 当 中 多 了 1 个 选 项。
（3）为 了 让 父 和 子 进 程 执 行 不 同 的 事 情，需 要 想 办 法 让 父 和 子 进 程 执 行 不 同 的 代 码 块。即 让 fork 具 有 不 同 的 返 回 值。
（4）return 语 句 被 父 和 子 进 程 分 别 执 行，即 return 语 句 被 父 子 进 程 共 享。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4cb23cf6c4554dba862a775025bef26e.png)
3. 一 个 变 量 怎 么 会 有 不 同 的 内 容？如 何 理 解?

（1）因 为 数 据 可 能 被 修 改，所 以 不 能 让 父 进 程 和 子 进 程 共 享 同 一 份 数 据。
（2）任 何 平 台，进 程 运 行 具 有 独 立 性。
（3）操 作 系 统 会 开 辟 空 间 让 子 进 程 去 新 的 空 间 修 改 被 称 为 数 据 层 面 的 写 时 拷 贝。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38cfb751ca764fcbb44ac4fea6627a08.png)

4. fork 函 数 究 竟 在 干 什 么？干 了 什 么？
（1）创 建 子 进 程，为 子 进 程 创 建 了 PCB，用 父 进 程 对 应 的 字 段 初 始 化 子 进 程，并 且 让 父 子 进 程 实 现 代 码 的 共 享。
（2）代 码 加 载 到 内 存 中 不 能 修 改，只 能 改 代 码 中 的 数 据。

5. 如 果 父 子 进 程 被 创 建 好，谁 先 运 行 由 调 度 器 决 定。挑 选 进 程 工 作 由 调 度 器 决 定 保 证 进 程 公 平 调 度。

6. 子 进 程 是 由 Bash 中 的 fork 创 建 的，子 进 程 还 可 以 继 续 fork() 创 建 自 己 的 子 进 程。
## 进 程 的 状 态
### 进 程 的 状 态
**运 行 队 列**：处 于 就 绪 状 态 的 进 程（或 线 程）的 集 合。这 些 进 程 已 获 得 除 CPU 之 外 的 所 有 必 要 资 源，只 需 等 待 CPU 调 度 即 可 执 行。

**运 行 状 态**: 并 不 意 味 着 进 程 一 定 在 运 行中，它 表 明 进 程 要 么 是 在 运 行 中 要 么 在 运 行 队 列 里。

**并 发 执 行**：在 一 个 时 间 段 内 所 有 的 进 程 都 会 被 执 行。

**进 程 切 换**：大 量 的 把 进 程 从 CPU 上 放 上 去，拿 下 来。

**阻 塞 状 态**：进 程 因 等 待 某 个 外 部 事 件 而 暂 时 无 法 继 续 执 行 的 状 态。
每 一 个 设 备 都 有 等 待 队 列。

**进 程 唤 醒**：当 处 于 阻 塞 状 态 的 进 程 所 等 待 的 事 件 发 生 时，由 操 作 系 统 将 其 从 阻 塞 状 态 转 换 为 就 绪 状 态 的 过 程。

**睡 眠 状 态（可 中 断 睡 眠）**：意 味 着 进 程 在 等 待 事 件 完 成。 

**磁 盘 休 眠 状 态**：有 时 候 也 叫 不 可 中 断 睡 眠 状 态，在 这 个 状 态 的 进 程 通 常 会 等 待 IO 的 结 束。

**挂 起 状 态**：进 程 被 从 内 存 中 “换 出” 到 外 存，暂 时 不 参 与 系 统 调 度，也 不 占 用 内 存 资 源 的 状 态。

**停 止 状 态**：可 以 通 过 发 送 SIGSTOP 信 号 给 进 程 来 停 止（T）进 程。这 个 被 暂 停 的 进 程 可 以 通 过 发 送 SIGCONT 信 号 让 进 程 继 续 运 行。

**死 亡 状 态**：这 个 状 态 只 是 一 个 返 回 状 态，你 不 会 在 任 务 列 表 里 看 到 这 个 状 态。
***
###  Linux 系 统 中 进 程 的 状 态
**kernel 源 代 码 里 的 状 态**
```
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};
```
**R 运 行 状 态**：并 不 意 味 着 进 程 一 定 在 运 行 中，它 表 明 进 程 要 么 是 在 运 行 中 要 么 在 运 行 队 列 里。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3820f3d99a1d47d698cd6a8e7d98955b.png)
进 程 陷 入 死 循 环，持 续 占 用 CPU，无 阻 塞 操 作，状 态 为 R+。
***
**S 睡 眠 状 态（可 中 断 睡 眠）（浅 度 睡 眠 状 态）**：意 味 着 进 程 在 等 待 事 件 完 成。
**情 况 1**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c4431330cc754b4ea49dcf0104be3883.png)
进 程 因 sleep(1) 主 动 进 入 可 中 断 睡 眠，状 态 为 S+。
***
**情 况 2**
当 程 序 需 要 等 待 输 入 时，进 程 为 睡 眠 状 态，也 就 是 阻 塞 状 态。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3e9246521dc04d16978aaf6969ab1975.png)
***
**情 况 3**
基 本 上 bash 都 是 睡 眠 状 态，即 等 待 用 户 输 入 指 令。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f9e841c9039646a6bdd99f621cef5348.png)
***
**D 磁 盘 休 眠 状 态（不 可 中 断 睡 眠 状 态）（深 度 睡 眠 状 态）**：在 这 个 状 态 的 进 程 通 常 会 等 待 IO 的 结 束。进 程 在 等 待 磁 盘 写 入 期 间，这 个 进 程 不 能 被 任 何 人 杀 掉。一 般 而 言，如 果 系 统 存 在 多 个 D 状 态，则 系 统 接 近 崩 溃 的 边 缘。
***

**T 停 止 状 态**：可 以 通 过 发 送 SIGSTOP 信 号 给 进 程 来 停 止（T）进 程。这 个 被 暂 停 的 进 程 可 以 通 过 发 送 SIGCONT 信 号 让 进 程 继 续 运 行。
<font color=orange>kill -l</font>
用 于 列 出 所 有 可 用 信 号。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/81b77ad4d6d348fcbc1e96d894bed169.png)
`kill -19 PID` - - - 暂 停 进 程
`kill -18 PID` - - - 继 续 进 程
Linux 系 统 下，进 程 由 暂 停 变 成 继 续，进 程 从 前 台 变 成 了 后 台 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c7fe22bbcb214b3d8358c63168ffabd0.png)

<font color=green>可 中 断 睡 眠 和 停 止 的 区 别</font>
S 是 “进 程 自 己 歇 会 儿，等 事 儿 办 完 再 干”，可 以 被 打 断；
T 是 “被 强 行 按 住 不 动”，除 非 明 确 放 行（SIGCONT），否 则 不 会 动。
| 对比项          | S（可中断睡眠）               | T（停止）                                     |
| --------------- | ----------------------------- | --------------------------------------------- |
| 本质            | 主动等待事件 / 资源，让出 CPU | 被外部信号强制暂停，被动冻结                  |
| 触发信号 / 操作 | 无特定信号（进程主动进入）    | SIGSTOP                                       |
| 对信号的响应    | 可被 SIGINT、SIGTERM 等唤醒   | 仅 SIGCONT 可唤醒，其他信号无效（除 SIGKILL） |
| 典型场景        | 等待 I/O、定时器、用户输入    | 被暂停的前台进程                              |
***
**t 追 踪 状 态**
追 踪 进 程 的 运 行 情 况。
<font color=blue>gdb 调 试</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f24996df95994ef39ef3651e2a5625e7.png)
***
**X 死 亡 状 态**：这 个 状 态 只 是 一 个 返 回 状 态，你 不 会 在 任 务 列 表 里 看 到 这 个 状 态。
进 程 死 掉 意 味 着 将 进 程 的 各 种 资 源 全 部 释 放 掉，相 当 于 终 止 态，将 进 程 放 入 垃 圾 回 收 队 列 中，操 作 系 统 会 删 掉 进 程。
***
**Z - 僵 尸 进 程**
僵 尸 状 态 是 一 个 比 较 特 殊 的 状 态。当 进 程 退 出 并 且 父 进 程 没 有 读 取 到 子 进 程 退 出 的 返 回 代 码 时 就 会 产 生 僵 死 (尸) 进 程，僵 尸 进 程 会 以 终 止 状 态 保 持 在 进 程 表 中，并 且 会 一 直 在 等 待 父 进 程 读 取 退 出 状 态 代 码。
只 要 子 进 程 退 出，父 进 程 还 在 运 行，但 父 进 程 没 有 读 取 子 进 程 状 态，子 进 程 进 入 Z 状 态。

`exit`
退 出 当 前 会 话 或 终 止 脚 本 执 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ee6280513c847cebd6c18e11db30baf.png)
***
**情 况 1**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4518c8512b124af7a2fbc14e5b221d4c.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fea7839b6f104285bb8b8100c31ed314.png)
`注 意`
上 面 的 图 片 中 子 进 程 变 为 z 进 程 应 该 是 第 6 次，这 是 因 为 先 运 行 可 执 行 程 序，切 换 到 左 边 时 慢 了 1 次。
5 秒 期 间 父 进 程 一 直 运 行，子 进 程 会 退 出。5 秒 后 父 进 程 还 在 运 行，子 进 程 变 成 僵 尸 进 程。
父 进 程 目 前 没 有 针 对 子 进 程 干 任 何 事 情，子 进 程 退 出 后 父 进 程 仍 然 运 行。
进 程 一 般 退 出 的 时 候，如 果 父 进 程 没 有 主 动 回 收 子 进 程 信 息，子 进 程 会 一 直 让 自 己 处 于 z 状 态。进 程 的 相 关 资 源 尤 其 是 test_struct 结 构 体 不 能 被 释 放，资 源 会 被 一 直 占 用。
***
<font color=orange>现 象</font>
5 秒 后，子 进 程 结 束 变 成 僵 尸 状 态，父 进 程 不 是 僵 尸 状 态 是 因 为 僵 尸 进 程 的 前 提 是 “进 程 已 终 止”，此 时 父 进 程 没 有 终 止。
父 进 程 的 父 进 程 是 bash，当 进 程 结 束 时，父 进 程 被 bash 回 收。bash 可 以 回 收 父 进 程 的 资 源，但 是 不 能 回 收 子 进 程 的 资 源。因 为 子 进 程 的 PCB（进 程 控 制 块）里 记 录 的 父 进 程 ID（PPID）。
如 果 父 进 程 先 死 亡，子 进 程 在 进 程 结 束 后 被 操 作 系 统（PID 为 1 的 systemd 进 程，系 统 的 根 进 程） 领 养 回 收。
<font color=red>父 亲 管 儿 子，祖 父 管 父 亲，跨 代 不 管。</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/df13af4fbde842c1aa66399d41183fa6.png)
**情 况 2**
父 进 程 提 前 退 出，子 进 程 不 退 出。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/df25097a64c74b14aeefd4d37ee69e91.png)
当 父 进 程 提 前 退 出，子 进 程 仍 然 在 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5fd13ec25c5d45308d56e9d351f75142.png)
注 意
上 图 中 父 进 程 提 前 退 出 以 后，子 进 程 的 进 程 编 号 为 1。

进 程 编 号（PID）为 1 的 进 程 是 系 统 的 “根 进 程”，也 就 是 操 作 系 统，是 内 核 启 动 后 创 建 的 第 一 个 用 户 态 进 程，所 有 其 他 用 户 进 程 最 终 都 由 它 直 接 或 间 接 衍 生（即 它 是 整 个 进 程 树 的 “祖 先”）。

父 子 进 程，父 进 程 先 退 出，子 进 程 的 父 进 程 会 被 变 成 1 号 进 程 （操 作 系 统）。父 进 程 是 1 号 进 程，被 称 作 孤 儿 进 程。该 进 程 被 系 统 所 领 养。

为 什 么 要 被 领 养？
因 为 孤 儿 进 程 未 来 也 会 推 出，也 要 被 释 放。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d4cdf68f0e454c41b1b5a216bfa278b7.png)
***
**僵 尸 进 程 危 害**
1. 进 程 的 退 出 状 态 必 须 被 维 持 下 去，因 为 他 要 告 诉 关 心 它 的 进 程（父 进 程），你 交 给 我 的 任 务，我 办 的 怎 么 样 了。可 父 进 程 如 果 一 直 不 读 取，那 子 进 程 就 一 直 处 于 Z 状 态。
2. 维 护 退 出 状 态 本 身 就 是 要 用 数 据 维 护，也 属 于 进 程 基 本 信 息，所 以 保 存 在 task_struct(PCB) 中，换 句 话 说，Z 状 态 一 直 不 退 出，PCB 一 直 都 要 维 护。
3. 父 进 程 创 建 大 量 子 进 程 却 不 回 收，会 导 致 内 存 资 源 浪 费 的 核 心 原 因 是 每 个 终 止 的 子 进 程 会 变 成 僵 尸 进 程，其 内 核 数 据 结 构（PCB，进 程 控 制 块）会 被 永 久 保 留，而 PCB 本 身 需 要 占 用 系 统 内 存（内 核 空 间）。
### 总 结
Linux 进 程 的 结 构 也 是 一 颗 多 叉 树 的 样 子。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1a8ae84e4a0847e088a4aa9ff5bffd3e.png)
***
### 前 台
**+**：进 程 属 于 前 台 进 程 组。当 程 序 在 前 台 运 行时，输 入 指 令 没 有 作 用，可 以 使 用 `ctrl + c` 终 止 程 序。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8afd45d0b35b4c95896a692bdec678bd.png)
***
### 后 台
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如 下 图 所 示，运 行 状 态 后 面 没 有 `+` 号，此 时 程 序 在 后 台 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e7ed3c1cd56a4969b3d648a03a3297e2.png)
**终 止 后 台 程 序**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输 入 `kill + PID`（正 常 终 止）或 者 `kill -9 PID`（强 制 终 止）。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/def8d96c61ca45148e614681065f66d7.png)
***
# 进 程 优 先 级
## 定 义
1. cpu 资 源 分 配 的 先 后 顺 序，就 是 指 进 程 的 优 先 权。
2. 优 先 权 高 的 进 程 有 优 先 执 行 权 利。配 置 进 程 优 先 权 对 多 任 务 环 境 的 linux 很 有 用，可 以 改 善 系 统 性 能。
3. 将 进 程 运 行 到 指 定 的 CPU 上，这 样 一 来，把 不 重 要 的 进 程 安 排 到 某 个 CPU，可 以 大 大 改 善 系 统 整 体 性 能。
4. 不 能 随 意 更 改 优 先 级。
## 原 因
资 源 是 有 限 的，进 程 是 多 个 的，决 定 了 进 程 之 间 是 竞 争 关 系。操 作 系 统 会 保 证 大 家 良 性 竞 争，确 认 优 先 级。如 果 进 程 长 时 间 得 不 到 CPU 资 源，该 进 程 的 代 码 长 时 间 无 法 得 到 推 进，造 成 了 进 程 的 饥 饿 问 题。
## 优 先 级 vs 权 限
权 限 决 定 的 是 能 还 是 不 能 访 问 资 源，优 先 级 已 经 可 以 访 问 资 源，谁 先 访 问 谁 后 访 问。
## ps
<font color=orange>ps -l</font>
显 示 当 前 终 端 下 的 进 程

<font color=green>ps -al</font>
显 示 当 前 终 端 下 的 所 有 进 程
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fb941e8bd7014f5ca5d0c265d927fbdd.png)
## 详 细 信 息
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/faac14451914405e90f9f5014dc61984.png)
**UID**：代 表 执 行 者 的 身 份
**PID**：代 表 这 个 进 程 的 代 号
**PPID**：代 表 这 个 进 程 是 由 哪 个 进 程 发 展 衍 生 而 来 的，亦 即 父 进 程 的 代 号。
**PRI**：代 表 这 个 进 程 可 被 执 行 的 优 先 级，其 值 越 小 优 先 级 越 高 越 早 被 执 行。
**NI**：代 表 这 个 进 程 的 nice 值。
## PRI and NI
1. PRI 也 还 是 比 较 好 理 解 的，即 进 程 的 优 先 级，或 者 程序被CPU执行的先后顺序，此值越小进程的优先级别越高
2. NI 是 nice 值，其 表 示 进 程 可 被 执 行 的 优 先 级 的 修 正 数 值。
3. PRI 值 越 小 越 快 被 执 行，加 入 nice 值 后，将 会 使 得 PRI 变 为：PRI(new) = PRI(old) + nice。
4. 当 nice 值 为 负 值 的 时 候，程 序 将 会 优 先 级 值 将 变 小，即 其 优 先 级 会 变 高，则 其 越 快 被 执 行
5. 调 整 进 程 优 先 级，在 Linux 下，就 是 调 整 进 程 nice 值 
6. Linux 不 会 过 多 的 让 用 户 调 整 优 先 级，在 用 户 的 范 围 内 进 行 优 先 级 调 整。nice 其 取 值 范 围 是 -20 至 19，一 共 40 个 级 别。
## PRI vs NI
1. 进 程 的 nice 值 不 是 进 程 的 优 先 级，但 是 进 程 nice 值 会 影 响 到 进 程 的 优 先 级 变 化。
2. nice 值 是 进 程 优 先 级 的 修 正 数 据。
## 修 改 nice

1. 先 使 用 `su` 切 换 到 root 用 户。

**普 通 用 户**：仅 能 设 置 Nice 值 ≥ 当 前 进 程 的 Nice 值（即 只 能 降 低 优 先 级，如 从 0 调 整 到 5），无 法 设 置 负 Nice 值（无 法 提 高 优 先 级）。

**root 用 户**：可 设 置 任 意 Nice 值（-20 ~ 19），能 调 整 所 有 用 户 的 进 程 优 先 级。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/88fd3ebf90d0431ea9148770f883779b.png)
3. 编 写 并 运 行 程 序，然 后 输 入 `top` 进 入 进 程 页 面。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38a0a05bef824e87a7efc83aa8fdcfe8.png)
4. 输 入 `r` 提 示 输 入 进 程 的 PID 值，只 能 是 整 数。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c4a135e10f8b4c70ac542b05a1d526f4.png)
5. 输 入 整 数，取 值 范 围 是 -20 至 19。如 果 小 于 -20 会 使 用 -20，反 之，如 果 大 于 19 会 使 用 19。无 论 是 否 修 改 过，始 终 是 在 原 来 基 础 上 增 加 或 者 减 少 的。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/29cee2f7b03440d2a6653120127c930c.png)
6. 如 果 没 有 切 换 到 root，可 能 会 出 现 如 下 的 错 误。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c443bfde4bc4477cb0061e41bab310bd.png)
7. 输 入 完 成 后，按 `q` 退 出 即 可。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5253d6a4b24c41cd99f657916423e409.png)
8. 使 用 `ps -al` 查 看 即 可。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f4fcb8aa93274f419193dbdbea3cc048.png)
Linux 内 核 大 O(1) 的 调 度 算 法。