# 管 理 进 程
## kill
`kill -9 PID`
杀 死（终 止）进 程。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c7c40c0c44ad449da8797b01a9f97fd6.png)
`ps 的 本 质 是 遍 历 链 表，然 后 得 到 所 有 进 程 的 相 关 信 息。`
## 系 统 调 用 接 口 
### getpid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获 得 进 程 的 标 识 符。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ea62bb2635f84dd1b0377687e3561d55.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2ec92113680248a2b63247e0f1b7f1b4.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使 用 `while :;do ps ajx | head -1 && ps ajx | grep test_debug;echo "--------------------------------------------------------------------------";sleep 1;done` 这 条 指 令 可 以 不 断 获 取 进 程 的 运 行 情 况。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/27c00ac5fed642828e5c6a457c246079.png)
### 父 进 程 - - - PPID
`getppid`

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PPID 就 是 子 进 程 用 来 记 录 父 进 程 的 唯 一 标 识 符，`getppid` 可 以 得 到 父 进 程 的 标 识 符。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e73f9b12e1bc4c12906ea586255895ff.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1a9ef7fac7e54466931b2e82499eae30.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4b713b84f9ab469a858afda459b98214.png)
***
### bash
[命 令 行 解 释 器](https://blog.csdn.net/2301_78847073/article/details/144883662?spm=1001.2014.3001.5501)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运 行 进 程 时，命 令 行 解 释 器 会 将 指 令 解 释 成 bash 的 子 进 程，由 子 进 程 执 行 对 应 的 命 令，进 程 出 问 题 不 影 响 对 应 的 bash 进 程。每 一 条 指 令 的 运 行 都 属 于 bash 的 子 进 程。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/da76968c07cc4ae68591233a06c4ea7f.png)
## 通 过 系 统 调 用 创 建 进 程
### fork
创 建 进 程
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/11d6fac3f7bc475b9e558f6da6a0442f.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d78e337404f5439f86fe63f7426918b2.png)
***
`没 有 fork`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/189f56917c2d4b62a603b7c56124cd62.png)
`有 fork`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7bf3e8715ce44f1ba6f389f0019028f8.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由 这 两 张 图 片 不 难 可 以 看 出，`fork` 后 面 的 代 码 被 执 行 了 2 次。因 为 fork 之 前 是 1 个 进 程，fork 之 后 是 2 个 进 程。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a1c6d7d4ba7f470c9ce6f1a42fd42653.png)
`fork 给 父 进 程 返 回 PID 为 子 进 程 返 回 0`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/411ffa20372f499494f97a388703c041.png)
<font color=orange>结 论</font>
1. fork > 0 和 fork = 0 同 时 存 在。
2. 父 子 关 系 成 立。
3. fork 之 后 的 代 码 是 2 个 进 程。这 里 存 在 2 个 进 程。
### 创 建 进 程 的 方 式
1. `./ 运 行 程 序` - - - 指 令 级 别 创 建 进 程
2. `fork` - - - 代 码 层 面 创 建 进 程。
### 创 建 子 进 程 的 步 骤
1. 创 建 子 进 程 PCB。
2. 填 充 PCB 对 应 的 内 容。
3. 让 子 进 程 和 父 进 程 指 向 同 样 的 代码
4. 父 子 进 程 都 有 独 立 的 task_struct，可 以 被 CPU 调 度 运 行 了。
### 四 个 问 题
1. 为 什 么 fork 要 给 子 进 程 返 回 0，给 父 进 程 返 回 子 进 程 pid？
`（1）为 了 让 fork 之 后 通 过 if 来 执 行 不 同 的 代 码 片 段。`
`（2）返 回 不 同 的 返 回 值，是 为 了 区 分 让 不 同 的 执 行 流 执 行 不 同 的 代 码 块。`
`（3）fork 之 后 的 父 子 进 程 代 码 共 享。原 因 是 因 为 父 进 程 指 向 的 代 码 和 数 据，子 进 程 此 时 没 有 执 向 代 码，子 进 程 只 能 指 向 和 父 进 程 一 样 的 代 码 和 数 据。`
<font color=orange>原 因：1 个 父 进 程 有 多 个 子 进 程，但 多 个 父 进 程 只 有 1 个 子 进 程，为 了 明 确 父 进 程 要 控 制 哪 一 个 子 进 程。</font>
2. 一 个 函 数 是 如 何 做 到 返 回 2 次 的 ？如 何 理 解？
（1）`进 程 = 内 核 数 据 结 构 + 代 码 和 数 据`
（2）创 建 子 进 程 的 本 质 是 进 程 当 中 多 了 1 个 选 项。
（3）为 了 让 父 和 子 进 程 执 行 不 同 的 事 情，需 要 想 办 法 让 父 和 子 进 程 执 行 不 同 的 代 码 块。即 让 fork 具 有 不 同 的 返 回 值。
（4）return 语 句 被 父 和 子 进 程 分 别 执 行，即 return 语 句 被 父 子 进 程 共 享。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4cb23cf6c4554dba862a775025bef26e.png)
3. 一 个 变 量 怎 么 会 有 不 同 的 内 容？如 何 理 解?

（1）因 为 数 据 可 能 被 修 改，所 以 不 能 让 父 进 程 和 子 进 程 共 享 同 一 份 数 据。
（2）任 何 平 台，进 程 运 行 具 有 独 立 性。
（3）操 作 系 统 会 开 辟 空 间 让 子 进 程 去 新 的 空 间 修 改 被 称 为 数 据 层 面 的 写 时 拷 贝。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38cfb751ca764fcbb44ac4fea6627a08.png)

4. fork 函 数 究 竟 在 干 什 么？干 了 什 么？
（1）创 建 子 进 程，为 子 进 程 创 建 了 PCB，用 父 进 程 对 应 的 字 段 初 始 化 子 进 程，并 且 让 父 子 进 程 实 现 代 码 的 共 享。
（2）代 码 加 载 到 内 存 中 不 能 修 改，只 能 改 代 码 中 的 数 据。

5. 如 果 父 子 进 程 被 创 建 好，谁 先 运 行 由 调 度 器 决 定。挑 选 进 程 工 作 由 调 度 器 决 定 保 证 进 程 公 平 调 度。

6. 子 进 程 是 由 Bash 中 的 fork 创 建 的，子 进 程 还 可 以 继 续 fork() 创 建 自 己 的 子 进 程。
## 进 程 的 状 态
### 进 程 的 状 态
**运 行 队 列**：处 于 就 绪 状 态 的 进 程（或 线 程）的 集 合。这 些 进 程 已 获 得 除 CPU 之 外 的 所 有 必 要 资 源，只 需 等 待 CPU 调 度 即 可 执 行。

**运 行 状 态**: 并 不 意 味 着 进 程 一 定 在 运 行中，它 表 明 进 程 要 么 是 在 运 行 中 要 么 在 运 行 队 列 里。

**并 发 执 行**：在 一 个 时 间 段 内 所 有 的 进 程 都 会 被 执 行。

**进 程 切 换**：大 量 的 把 进 程 从 CPU 上 放 上 去，拿 下 来。

**阻 塞 状 态**：进 程 因 等 待 某 个 外 部 事 件 而 暂 时 无 法 继 续 执 行 的 状 态。
每 一 个 设 备 都 有 等 待 队 列。

**进 程 唤 醒**：当 处 于 阻 塞 状 态 的 进 程 所 等 待 的 事 件 发 生 时，由 操 作 系 统 将 其 从 阻 塞 状 态 转 换 为 就 绪 状 态 的 过 程。

**睡 眠 状 态（可 中 断 睡 眠）**：意 味 着 进 程 在 等 待 事 件 完 成。 

**磁 盘 休 眠 状 态**：有 时 候 也 叫 不 可 中 断 睡 眠 状 态，在 这 个 状 态 的 进 程 通 常 会 等 待 IO 的 结 束。

**挂 起 状 态**：进 程 被 从 内 存 中 “换 出” 到 外 存，暂 时 不 参 与 系 统 调 度，也 不 占 用 内 存 资 源 的 状 态。

**停 止 状 态**：可 以 通 过 发 送 SIGSTOP 信 号 给 进 程 来 停 止（T）进 程。这 个 被 暂 停 的 进 程 可 以 通 过 发 送 SIGCONT 信 号 让 进 程 继 续 运 行。

**死 亡 状 态**：这 个 状 态 只 是 一 个 返 回 状 态，你 不 会 在 任 务 列 表 里 看 到 这 个 状 态。
***
###  Linux 系 统 中 进 程 的 状 态
**kernel 源 代 码 里 的 状 态**
```
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};
```
**R 运 行 状 态**：并 不 意 味 着 进 程 一 定 在 运 行 中，它 表 明 进 程 要 么 是 在 运 行 中 要 么 在 运 行 队 列 里。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3820f3d99a1d47d698cd6a8e7d98955b.png)
进 程 陷 入 死 循 环，持 续 占 用 CPU，无 阻 塞 操 作，状 态 为 R+。
***
**S 睡 眠 状 态（可 中 断 睡 眠）（浅 度 睡 眠 状 态）**：意 味 着 进 程 在 等 待 事 件 完 成。
**情 况 1**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c4431330cc754b4ea49dcf0104be3883.png)
进 程 因 sleep(1) 主 动 进 入 可 中 断 睡 眠，状 态 为 S+。
***
**情 况 2**
当 程 序 需 要 等 待 输 入 时，进 程 为 睡 眠 状 态，也 就 是 阻 塞 状 态。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3e9246521dc04d16978aaf6969ab1975.png)
***
**情 况 3**
基 本 上 bash 都 是 睡 眠 状 态，即 等 待 用 户 输 入 指 令。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f9e841c9039646a6bdd99f621cef5348.png)
***
**D 磁 盘 休 眠 状 态（不 可 中 断 睡 眠 状 态）（深 度 睡 眠 状 态）**：在 这 个 状 态 的 进 程 通 常 会 等 待 IO 的 结 束。进 程 在 等 待 磁 盘 写 入 期 间，这 个 进 程 不 能 被 任 何 人 杀 掉。一 般 而 言，如 果 系 统 存 在 多 个 D 状 态，则 系 统 接 近 崩 溃 的 边 缘。
***

**T 停 止 状 态**：可 以 通 过 发 送 SIGSTOP 信 号 给 进 程 来 停 止（T）进 程。这 个 被 暂 停 的 进 程 可 以 通 过 发 送 SIGCONT 信 号 让 进 程 继 续 运 行。
<font color=orange>kill -l</font>
用 于 列 出 所 有 可 用 信 号。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/81b77ad4d6d348fcbc1e96d894bed169.png)
`kill -19 PID` - - - 暂 停 进 程
`kill -18 PID` - - - 继 续 进 程
Linux 系 统 下，进 程 由 暂 停 变 成 继 续，进 程 从 前 台 变 成 了 后 台 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c7fe22bbcb214b3d8358c63168ffabd0.png)

<font color=green>可 中 断 睡 眠 和 停 止 的 区 别</font>
S 是 “进 程 自 己 歇 会 儿，等 事 儿 办 完 再 干”，可 以 被 打 断；
T 是 “被 强 行 按 住 不 动”，除 非 明 确 放 行（SIGCONT），否 则 不 会 动。
| 对比项          | S（可中断睡眠）               | T（停止）                                     |
| --------------- | ----------------------------- | --------------------------------------------- |
| 本质            | 主动等待事件 / 资源，让出 CPU | 被外部信号强制暂停，被动冻结                  |
| 触发信号 / 操作 | 无特定信号（进程主动进入）    | SIGSTOP                                       |
| 对信号的响应    | 可被 SIGINT、SIGTERM 等唤醒   | 仅 SIGCONT 可唤醒，其他信号无效（除 SIGKILL） |
| 典型场景        | 等待 I/O、定时器、用户输入    | 被暂停的前台进程                              |
***
**t 追 踪 状 态**
追 踪 进 程 的 运 行 情 况。
<font color=blue>gdb 调 试</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f24996df95994ef39ef3651e2a5625e7.png)
***
**X 死 亡 状 态**：这 个 状 态 只 是 一 个 返 回 状 态，你 不 会 在 任 务 列 表 里 看 到 这 个 状 态。
进 程 死 掉 意 味 着 将 进 程 的 各 种 资 源 全 部 释 放 掉，相 当 于 终 止 态，将 进 程 放 入 垃 圾 回 收 队 列 中，操 作 系 统 会 删 掉 进 程。
***
**Z - 僵 尸 进 程**
僵 尸 状 态 是 一 个 比 较 特 殊 的 状 态。当 进 程 退 出 并 且 父 进 程 没 有 读 取 到 子 进 程 退 出 的 返 回 代 码 时 就 会 产 生 僵 死 (尸) 进 程，僵 尸 进 程 会 以 终 止 状 态 保 持 在 进 程 表 中，并 且 会 一 直 在 等 待 父 进 程 读 取 退 出 状 态 代 码。
只 要 子 进 程 退 出，父 进 程 还 在 运 行，但 父 进 程 没 有 读 取 子 进 程 状 态，子 进 程 进 入 Z 状 态。
`exit`
退 出 当 前 会 话 或 终 止 脚 本 执 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ee6280513c847cebd6c18e11db30baf.png)
5 秒 期 间 父 进 程 一 直 运 行，子 进 程 会 退 出。父 进 程 目 前 没 有 针 对 子 进 程 干 任 何 事 情，子 进 程 退 出 后 父 进 程 仍 然 运 行。

***
### 前 台
**+**：进 程 属 于 前 台 进 程 组。当 程 序 在 前 台 运 行时，输 入 指 令 没 有 作 用，可 以 使 用 `ctrl + c` 终 止 程 序。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8afd45d0b35b4c95896a692bdec678bd.png)
***
### 后 台
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如 下 图 所 示，运 行 状 态 后 面 没 有 `+` 号，此 时 程 序 在 后 台 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e7ed3c1cd56a4969b3d648a03a3297e2.png)
**终 止 后 台 程 序**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输 入 `kill + PID`（正 常 终 止）或 者 `kill -9 PID`（强 制 终 止）。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/def8d96c61ca45148e614681065f66d7.png)