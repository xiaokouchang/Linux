# 管 理 进 程
## kill
`kill -9 PID`
杀 死（终 止）进 程。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c7c40c0c44ad449da8797b01a9f97fd6.png)
`ps 的 本 质 是 遍 历 链 表，然 后 得 到 所 有 进 程 的 相 关 信 息。`
## 系 统 调 用 接 口 
### getpid
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;获 得 进 程 的 标 识 符。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ea62bb2635f84dd1b0377687e3561d55.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2ec92113680248a2b63247e0f1b7f1b4.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使 用 `while :;do ps ajx | head -1 && ps ajx | grep test_debug;echo "--------------------------------------------------------------------------";sleep 1;done` 这 条 指 令 可 以 不 断 获 取 进 程 的 运 行 情 况。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/27c00ac5fed642828e5c6a457c246079.png)
### 父 进 程 - - - PPID
`getppid`

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PPID 就 是 子 进 程 用 来 记 录 父 进 程 的 唯 一 标 识 符，`getppid` 可 以 得 到 父 进 程 的 标 识 符。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e73f9b12e1bc4c12906ea586255895ff.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1a9ef7fac7e54466931b2e82499eae30.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4b713b84f9ab469a858afda459b98214.png)
***
### bash
[命 令 行 解 释 器](https://blog.csdn.net/2301_78847073/article/details/144883662?spm=1001.2014.3001.5501)

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运 行 进 程 时，命 令 行 解 释 器 会 将 指 令 解 释 成 bash 的 子 进 程，由 子 进 程 执 行 对 应 的 命 令，进 程 出 问 题 不 影 响 对 应 的 bash 进 程。每 一 条 指 令 的 运 行 都 属 于 bash 的 子 进 程。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/da76968c07cc4ae68591233a06c4ea7f.png)
## 通 过 系 统 调 用 创 建 进 程
### fork
创 建 进 程
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/11d6fac3f7bc475b9e558f6da6a0442f.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d78e337404f5439f86fe63f7426918b2.png)
***
`没 有 fork`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/189f56917c2d4b62a603b7c56124cd62.png)
`有 fork`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7bf3e8715ce44f1ba6f389f0019028f8.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由 这 两 张 图 片 不 难 可 以 看 出，`fork` 后 面 的 代 码 被 执 行 了 2 次。因 为 fork 之 前 是 1 个 进 程，fork 之 后 是 2 个 进 程。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a1c6d7d4ba7f470c9ce6f1a42fd42653.png)
`fork 给 父 进 程 返 回 PID 为 子 进 程 返 回 0`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/411ffa20372f499494f97a388703c041.png)
<font color=orange>结 论</font>
1. fork > 0 和 fork = 0 同 时 存 在。
2. 父 子 关 系 成 立。
3. fork 之 后 的 代 码 是 2 个 进 程。这 里 存 在 2 个 进 程。
### 创 建 进 程 的 方 式
1. `./ 运 行 程 序` - - - 指 令 级 别 创 建 进 程
2. `fork` - - - 代 码 层 面 创 建 进 程。
### 创 建 子 进 程 的 步 骤
1. 创 建 子 进 程 PCB。
2. 填 充 PCB 对 应 的 内 容。
3. 让 子 进 程 和 父 进 程 指 向 同 样 的 代码
4. 父 子 进 程 都 有 独 立 的 task_struct，可 以 被 CPU 调 度 运 行 了。
### 四 个 问 题
1. 为 什 么 fork 要 给 子 进 程 返 回 0，给 父 进 程 返 回 子 进 程 pid？
`（1）为 了 让 fork 之 后 通 过 if 来 执 行 不 同 的 代 码 片 段。`
`（2）返 回 不 同 的 返 回 值，是 为 了 区 分 让 不 同 的 执 行 流 执 行 不 同 的 代 码 块。`
`（3）fork 之 后 的 父 子 进 程 代 码 共 享。原 因 是 因 为 父 进 程 指 向 的 代 码 和 数 据，子 进 程 此 时 没 有 执 向 代 码，子 进 程 只 能 指 向 和 父 进 程 一 样 的 代 码 和 数 据。`
<font color=orange>原 因：1 个 父 进 程 有 多 个 子 进 程，但 多 个 父 进 程 只 有 1 个 子 进 程，为 了 明 确 父 进 程 要 控 制 哪 一 个 子 进 程。</font>
2. 一 个 函 数 是 如 何 做 到 返 回 2 次 的 ？如 何 理 解？
（1）`进 程 = 内 核 数 据 结 构 + 代 码 和 数 据`
（2）创 建 子 进 程 的 本 质 是 进 程 当 中 多 了 1 个 选 项。
（3）为 了 让 父 和 子 进 程 执 行 不 同 的 事 情，需 要 想 办 法 让 父 和 子 进 程 执 行 不 同 的 代 码 块。即 让 fork 具 有 不 同 的 返 回 值。
（4）return 语 句 被 父 和 子 进 程 分 别 执 行，即 return 语 句 被 父 子 进 程 共 享。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4cb23cf6c4554dba862a775025bef26e.png)
3. 一 个 变 量 怎 么 会 有 不 同 的 内 容？如 何 理 解?

（1）因 为 数 据 可 能 被 修 改，所 以 不 能 让 父 进 程 和 子 进 程 共 享 同 一 份 数 据。
（2）任 何 平 台，进 程 运 行 具 有 独 立 性。
（3）操 作 系 统 会 开 辟 空 间 让 子 进 程 去 新 的 空 间 修 改 被 称 为 数 据 层 面 的 写 时 拷 贝。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38cfb751ca764fcbb44ac4fea6627a08.png)

4. fork 函 数 究 竟 在 干 什 么？干 了 什 么？
（1）创 建 子 进 程，为 子 进 程 创 建 了 PCB，用 父 进 程 对 应 的 字 段 初 始 化 子 进 程，并 且 让 父 子 进 程 实 现 代 码 的 共 享。
（2）代 码 加 载 到 内 存 中 不 能 修 改，只 能 改 代 码 中 的 数 据。

5. 如 果 父 子 进 程 被 创 建 好，谁 先 运 行 由 调 度 器 决 定。挑 选 进 程 工 作 由 调 度 器 决 定 保 证 进 程 公 平 调 度。

6. 子 进 程 是 由 Bash 中 的 fork 创 建 的，子 进 程 还 可 以 继 续 fork() 创 建 自 己 的 子 进 程。
## 进 程 的 状 态
### 进 程 的 状 态
**运 行 队 列**：处 于 就 绪 状 态 的 进 程（或 线 程）的 集 合。这 些 进 程 已 获 得 除 CPU 之 外 的 所 有 必 要 资 源，只 需 等 待 CPU 调 度 即 可 执 行。

**运 行 状 态**: 并 不 意 味 着 进 程 一 定 在 运 行中，它 表 明 进 程 要 么 是 在 运 行 中 要 么 在 运 行 队 列 里。

**并 发 执 行**：在 一 个 时 间 段 内 所 有 的 进 程 都 会 被 执 行。

**进 程 切 换**：大 量 的 把 进 程 从 CPU 上 放 上 去，拿 下 来。

**阻 塞 状 态**：进 程 因 等 待 某 个 外 部 事 件 而 暂 时 无 法 继 续 执 行 的 状 态。
每 一 个 设 备 都 有 等 待 队 列。

**进 程 唤 醒**：当 处 于 阻 塞 状 态 的 进 程 所 等 待 的 事 件 发 生 时，由 操 作 系 统 将 其 从 阻 塞 状 态 转 换 为 就 绪 状 态 的 过 程。

**睡 眠 状 态（可 中 断 睡 眠）**：意 味 着 进 程 在 等 待 事 件 完 成。 

**磁 盘 休 眠 状 态**：有 时 候 也 叫 不 可 中 断 睡 眠 状 态，在 这 个 状 态 的 进 程 通 常 会 等 待 IO 的 结 束。

**挂 起 状 态**：进 程 被 从 内 存 中 “换 出” 到 外 存，暂 时 不 参 与 系 统 调 度，也 不 占 用 内 存 资 源 的 状 态。

**停 止 状 态**：可 以 通 过 发 送 SIGSTOP 信 号 给 进 程 来 停 止（T）进 程。这 个 被 暂 停 的 进 程 可 以 通 过 发 送 SIGCONT 信 号 让 进 程 继 续 运 行。

**死 亡 状 态**：这 个 状 态 只 是 一 个 返 回 状 态，你 不 会 在 任 务 列 表 里 看 到 这 个 状 态。
***
###  Linux 系 统 中 进 程 的 状 态
**kernel 源 代 码 里 的 状 态**
```
/*
* The task state array is a strange "bitmap" of
* reasons to sleep. Thus "running" is zero, and
* you can test for combinations of others with
* simple bit tests.
*/
static const char * const task_state_array[] = {
"R (running)", /* 0 */
"S (sleeping)", /* 1 */
"D (disk sleep)", /* 2 */
"T (stopped)", /* 4 */
"t (tracing stop)", /* 8 */
"X (dead)", /* 16 */
"Z (zombie)", /* 32 */
};
```
**R 运 行 状 态**：并 不 意 味 着 进 程 一 定 在 运 行 中，它 表 明 进 程 要 么 是 在 运 行 中 要 么 在 运 行 队 列 里。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3820f3d99a1d47d698cd6a8e7d98955b.png)
进 程 陷 入 死 循 环，持 续 占 用 CPU，无 阻 塞 操 作，状 态 为 R+。
***
**S 睡 眠 状 态（可 中 断 睡 眠）（浅 度 睡 眠 状 态）**：意 味 着 进 程 在 等 待 事 件 完 成。
**情 况 1**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c4431330cc754b4ea49dcf0104be3883.png)
进 程 因 sleep(1) 主 动 进 入 可 中 断 睡 眠，状 态 为 S+。
***
**情 况 2**
当 程 序 需 要 等 待 输 入 时，进 程 为 睡 眠 状 态，也 就 是 阻 塞 状 态。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3e9246521dc04d16978aaf6969ab1975.png)
***
**情 况 3**
基 本 上 bash 都 是 睡 眠 状 态，即 等 待 用 户 输 入 指 令。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f9e841c9039646a6bdd99f621cef5348.png)
***
**D 磁 盘 休 眠 状 态（不 可 中 断 睡 眠 状 态）（深 度 睡 眠 状 态）**：在 这 个 状 态 的 进 程 通 常 会 等 待 IO 的 结 束。进 程 在 等 待 磁 盘 写 入 期 间，这 个 进 程 不 能 被 任 何 人 杀 掉。一 般 而 言，如 果 系 统 存 在 多 个 D 状 态，则 系 统 接 近 崩 溃 的 边 缘。
***

**T 停 止 状 态**：可 以 通 过 发 送 SIGSTOP 信 号 给 进 程 来 停 止（T）进 程。这 个 被 暂 停 的 进 程 可 以 通 过 发 送 SIGCONT 信 号 让 进 程 继 续 运 行。
<font color=orange>kill -l</font>
用 于 列 出 所 有 可 用 信 号。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/81b77ad4d6d348fcbc1e96d894bed169.png)
`kill -19 PID` - - - 暂 停 进 程
`kill -18 PID` - - - 继 续 进 程
Linux 系 统 下，进 程 由 暂 停 变 成 继 续，进 程 从 前 台 变 成 了 后 台 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c7fe22bbcb214b3d8358c63168ffabd0.png)

<font color=green>可 中 断 睡 眠 和 停 止 的 区 别</font>
S 是 “进 程 自 己 歇 会 儿，等 事 儿 办 完 再 干”，可 以 被 打 断；
T 是 “被 强 行 按 住 不 动”，除 非 明 确 放 行（SIGCONT），否 则 不 会 动。
| 对比项          | S（可中断睡眠）               | T（停止）                                     |
| --------------- | ----------------------------- | --------------------------------------------- |
| 本质            | 主动等待事件 / 资源，让出 CPU | 被外部信号强制暂停，被动冻结                  |
| 触发信号 / 操作 | 无特定信号（进程主动进入）    | SIGSTOP                                       |
| 对信号的响应    | 可被 SIGINT、SIGTERM 等唤醒   | 仅 SIGCONT 可唤醒，其他信号无效（除 SIGKILL） |
| 典型场景        | 等待 I/O、定时器、用户输入    | 被暂停的前台进程                              |
***
**t 追 踪 状 态**
追 踪 进 程 的 运 行 情 况。
<font color=blue>gdb 调 试</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f24996df95994ef39ef3651e2a5625e7.png)
***
**X 死 亡 状 态**：这 个 状 态 只 是 一 个 返 回 状 态，你 不 会 在 任 务 列 表 里 看 到 这 个 状 态。
进 程 死 掉 意 味 着 将 进 程 的 各 种 资 源 全 部 释 放 掉，相 当 于 终 止 态，将 进 程 放 入 垃 圾 回 收 队 列 中，操 作 系 统 会 删 掉 进 程。
***
**Z - 僵 尸 进 程**
僵 尸 状 态 是 一 个 比 较 特 殊 的 状 态。当 进 程 退 出 并 且 父 进 程 没 有 读 取 到 子 进 程 退 出 的 返 回 代 码 时 就 会 产 生 僵 死 (尸) 进 程，僵 尸 进 程 会 以 终 止 状 态 保 持 在 进 程 表 中，并 且 会 一 直 在 等 待 父 进 程 读 取 退 出 状 态 代 码。
只 要 子 进 程 退 出，父 进 程 还 在 运 行，但 父 进 程 没 有 读 取 子 进 程 状 态，子 进 程 进 入 Z 状 态。

`exit`
退 出 当 前 会 话 或 终 止 脚 本 执 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0ee6280513c847cebd6c18e11db30baf.png)
***
**情 况 1**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4518c8512b124af7a2fbc14e5b221d4c.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fea7839b6f104285bb8b8100c31ed314.png)
`注 意`
上 面 的 图 片 中 子 进 程 变 为 z 进 程 应 该 是 第 6 次，这 是 因 为 先 运 行 可 执 行 程 序，切 换 到 左 边 时 慢 了 1 次。
5 秒 期 间 父 进 程 一 直 运 行，子 进 程 会 退 出。5 秒 后 父 进 程 还 在 运 行，子 进 程 变 成 僵 尸 进 程。
父 进 程 目 前 没 有 针 对 子 进 程 干 任 何 事 情，子 进 程 退 出 后 父 进 程 仍 然 运 行。
进 程 一 般 退 出 的 时 候，如 果 父 进 程 没 有 主 动 回 收 子 进 程 信 息，子 进 程 会 一 直 让 自 己 处 于 z 状 态。进 程 的 相 关 资 源 尤 其 是 test_struct 结 构 体 不 能 被 释 放，资 源 会 被 一 直 占 用。
***
<font color=orange>现 象</font>
5 秒 后，子 进 程 结 束 变 成 僵 尸 状 态，父 进 程 不 是 僵 尸 状 态 是 因 为 僵 尸 进 程 的 前 提 是 “进 程 已 终 止”，此 时 父 进 程 没 有 终 止。
父 进 程 的 父 进 程 是 bash，当 进 程 结 束 时，父 进 程 被 bash 回 收。bash 可 以 回 收 父 进 程 的 资 源，但 是 不 能 回 收 子 进 程 的 资 源。因 为 子 进 程 的 PCB（进 程 控 制 块）里 记 录 的 父 进 程 ID（PPID）。
如 果 父 进 程 先 死 亡，子 进 程 在 进 程 结 束 后 被 操 作 系 统（PID 为 1 的 systemd 进 程，系 统 的 根 进 程） 领 养 回 收。
<font color=red>父 亲 管 儿 子，祖 父 管 父 亲，跨 代 不 管。</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/df13af4fbde842c1aa66399d41183fa6.png)
**情 况 2**
父 进 程 提 前 退 出，子 进 程 不 退 出。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/df25097a64c74b14aeefd4d37ee69e91.png)
当 父 进 程 提 前 退 出，子 进 程 仍 然 在 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5fd13ec25c5d45308d56e9d351f75142.png)
注 意
上 图 中 父 进 程 提 前 退 出 以 后，子 进 程 的 进 程 编 号 为 1。

进 程 编 号（PID）为 1 的 进 程 是 系 统 的 “根 进 程”，也 就 是 操 作 系 统，是 内 核 启 动 后 创 建 的 第 一 个 用 户 态 进 程，所 有 其 他 用 户 进 程 最 终 都 由 它 直 接 或 间 接 衍 生（即 它 是 整 个 进 程 树 的 “祖 先”）。

父 子 进 程，父 进 程 先 退 出，子 进 程 的 父 进 程 会 被 变 成 1 号 进 程 （操 作 系 统）。父 进 程 是 1 号 进 程，被 称 作 孤 儿 进 程。该 进 程 被 系 统 所 领 养。

为 什 么 要 被 领 养？
因 为 孤 儿 进 程 未 来 也 会 推 出，也 要 被 释 放。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d4cdf68f0e454c41b1b5a216bfa278b7.png)
***
**僵 尸 进 程 危 害**
1. 进 程 的 退 出 状 态 必 须 被 维 持 下 去，因 为 他 要 告 诉 关 心 它 的 进 程（父 进 程），你 交 给 我 的 任 务，我 办 的 怎 么 样 了。可 父 进 程 如 果 一 直 不 读 取，那 子 进 程 就 一 直 处 于 Z 状 态。
2. 维 护 退 出 状 态 本 身 就 是 要 用 数 据 维 护，也 属 于 进 程 基 本 信 息，所 以 保 存 在 task_struct(PCB) 中，换 句 话 说，Z 状 态 一 直 不 退 出，PCB 一 直 都 要 维 护。
3. 父 进 程 创 建 大 量 子 进 程 却 不 回 收，会 导 致 内 存 资 源 浪 费 的 核 心 原 因 是 每 个 终 止 的 子 进 程 会 变 成 僵 尸 进 程，其 内 核 数 据 结 构（PCB，进 程 控 制 块）会 被 永 久 保 留，而 PCB 本 身 需 要 占 用 系 统 内 存（内 核 空 间）。
### 总 结
Linux 进 程 的 结 构 也 是 一 颗 多 叉 树 的 样 子。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/1a8ae84e4a0847e088a4aa9ff5bffd3e.png)
***
### 前 台
**+**：进 程 属 于 前 台 进 程 组。当 程 序 在 前 台 运 行时，输 入 指 令 没 有 作 用，可 以 使 用 `ctrl + c` 终 止 程 序。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8afd45d0b35b4c95896a692bdec678bd.png)
***
### 后 台
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如 下 图 所 示，运 行 状 态 后 面 没 有 `+` 号，此 时 程 序 在 后 台 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e7ed3c1cd56a4969b3d648a03a3297e2.png)
**终 止 后 台 程 序**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;输 入 `kill + PID`（正 常 终 止）或 者 `kill -9 PID`（强 制 终 止）。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/def8d96c61ca45148e614681065f66d7.png)
***
# 进 程 优 先 级
## 定 义
1. cpu 资 源 分 配 的 先 后 顺 序，就 是 指 进 程 的 优 先 权。
2. 优 先 权 高 的 进 程 有 优 先 执 行 权 利。配 置 进 程 优 先 权 对 多 任 务 环 境 的 linux 很 有 用，可 以 改 善 系 统 性 能。
3. 将 进 程 运 行 到 指 定 的 CPU 上，这 样 一 来，把 不 重 要 的 进 程 安 排 到 某 个 CPU，可 以 大 大 改 善 系 统 整 体 性 能。
4. 不 能 随 意 更 改 优 先 级。
## 原 因
资 源 是 有 限 的，进 程 是 多 个 的，决 定 了 进 程 之 间 是 竞 争 关 系。操 作 系 统 会 保 证 大 家 良 性 竞 争，确 认 优 先 级。如 果 进 程 长 时 间 得 不 到 CPU 资 源，该 进 程 的 代 码 长 时 间 无 法 得 到 推 进，造 成 了 进 程 的 饥 饿 问 题。
## 优 先 级 vs 权 限
权 限 决 定 的 是 能 还 是 不 能 访 问 资 源，优 先 级 已 经 可 以 访 问 资 源，谁 先 访 问 谁 后 访 问。
## ps
<font color=orange>ps -l</font>
显 示 当 前 终 端 下 的 进 程

<font color=green>ps -al</font>
显 示 当 前 终 端 下 的 所 有 进 程
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/fb941e8bd7014f5ca5d0c265d927fbdd.png)
## 详 细 信 息
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/faac14451914405e90f9f5014dc61984.png)
**UID**：代 表 执 行 者 的 身 份
**PID**：代 表 这 个 进 程 的 代 号
**PPID**：代 表 这 个 进 程 是 由 哪 个 进 程 发 展 衍 生 而 来 的，亦 即 父 进 程 的 代 号。
**PRI**：代 表 这 个 进 程 可 被 执 行 的 优 先 级，其 值 越 小 优 先 级 越 高 越 早 被 执 行。
**NI**：代 表 这 个 进 程 的 nice 值。
## PRI and NI
1. PRI 也 还 是 比 较 好 理 解 的，即 进 程 的 优 先 级，或 者 程序被CPU执行的先后顺序，此值越小进程的优先级别越高
2. NI 是 nice 值，其 表 示 进 程 可 被 执 行 的 优 先 级 的 修 正 数 值。
3. PRI 值 越 小 越 快 被 执 行，加 入 nice 值 后，将 会 使 得 PRI 变 为：PRI(new) = PRI(old) + nice。
4. 当 nice 值 为 负 值 的 时 候，程 序 将 会 优 先 级 值 将 变 小，即 其 优 先 级 会 变 高，则 其 越 快 被 执 行
5. 调 整 进 程 优 先 级，在 Linux 下，就 是 调 整 进 程 nice 值 
6. Linux 不 会 过 多 的 让 用 户 调 整 优 先 级，在 用 户 的 范 围 内 进 行 优 先 级 调 整。nice 其 取 值 范 围 是 -20 至 19，一 共 40 个 级 别。
## PRI vs NI
1. 进 程 的 nice 值 不 是 进 程 的 优 先 级，但 是 进 程 nice 值 会 影 响 到 进 程 的 优 先 级 变 化。
2. nice 值 是 进 程 优 先 级 的 修 正 数 据。
## 修 改 nice

1. 先 使 用 `su` 切 换 到 root 用 户。

**普 通 用 户**：仅 能 设 置 Nice 值 ≥ 当 前 进 程 的 Nice 值（即 只 能 降 低 优 先 级，如 从 0 调 整 到 5），无 法 设 置 负 Nice 值（无 法 提 高 优 先 级）。

**root 用 户**：可 设 置 任 意 Nice 值（-20 ~ 19），能 调 整 所 有 用 户 的 进 程 优 先 级。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/88fd3ebf90d0431ea9148770f883779b.png)
3. 编 写 并 运 行 程 序，然 后 输 入 `top` 进 入 进 程 页 面。
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/38a0a05bef824e87a7efc83aa8fdcfe8.png)

4. 输 入 `r` 提 示 输 入 进 程 的 PID 值，只 能 是 整 数。
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c4a135e10f8b4c70ac542b05a1d526f4.png)

5. 输 入 整 数，取 值 范 围 是 -20 至 19。如 果 小 于 -20 会 使 用 -20，反 之，如 果 大 于 19 会 使 用 19。无 论 是 否 修 改 过，始 终 是 在 原 来 基 础 上 增 加 或 者 减 少 的。
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/29cee2f7b03440d2a6653120127c930c.png)

6. 如 果 没 有 切 换 到 root，可 能 会 出 现 如 下 的 错 误。
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c443bfde4bc4477cb0061e41bab310bd.png)

7. 输 入 完 成 后，按 `q` 退 出 即 可。
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/5253d6a4b24c41cd99f657916423e409.png)

8. 使 用 `ps -al` 查 看 即 可。
    ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f4fcb8aa93274f419193dbdbea3cc048.png)
    Linux 内 核 大 O(1) 的 调 度 算 法。
    
    ## 其 他 概 念
    <font color=red>竞 争 性</font>：系 统 进 程 数 目 众 多，而 CPU 资 源 只 有 少 量，甚 至 1 个，所 以 进 程 之 间 是 具 有 竞 争 属 性 的。为 了 高 效 完 成 任 务，更 合 理 竞 争 相 关 资 源，便 具 有 了 优 先 级。
    
    <font color=blue>独 立 性</font>：多 进 程 运 行，需 要 独 享 各 种 资 源，多 进 程 运 行 期 间 互 不 干 扰。
    
    <font color=orange>并 行</font>：多 个 进 程 在 多 个 CPU 下 分 别，同 时 进 行 运 行，这 称 之 为 并 行。
    
    <font color=green>并 发</font>：多 个 进 程 在 一 个 CPU 下 采 用 进 程 切 换 的 方 式，在 一 段 时 间 之 内，让 多 个 进 程 都 得 以 推 进，称 之 为 并 发。
    ## 进 程 切 换
    1. 基 于 进 程 切 换 和 时 间 片 轮 转 的 调 度 算 法。
    2. 函 数 返 回 值 会 被 外 部 拿 到，通 过 CPU 的 寄 存 器 得 到 的，取 决 于 编 译 器。
    3. 系 统 通 过 程 序 计 数 器 pc，eip，即 记 录 当 前 进 程 正 在 执 行 指 令 的 下 一 行 指 令 的 地 址 来 得 到 进 程 执 行 到 哪 行 代 码 了。
    4. 通 用 寄 存 器 有 很 多，主 要 是 将 进 程 的 高 频 数 据 放 入 寄 存 器 中，用 来 提 高 效 率。
    5. cpu 的 寄 存 器 里 面 保 存 的 是 进 程 相 关 的 临 时 数 据 被 称 作 进 程 的 上 下 文。进 程 从 CPU 离 开 的 时 候，要 将 自 己 的 上 下 文 数 据 保 存 好，甚 至 带 走。保 存 的 目 的 是 为 了 恢 复 未 来 的 数 据。
    6. 进 程 在 被 切 换 时，会 保 存 上 下 文 和 恢 复 上 下 文。

# 环 境 变 量
## 定 义
环 境 变 量 一 般 是 指 在 操 作 系 统 中 用 来 指 定 操 作 系 统 运 行 环 境 的 一 些 参 数，环 境 变 量 通 常 具 有 某 些 特 殊 用 途，还 有 在 系 统 当 中 通 常 具 有 全 局 特 性。
环 境 变 量 是 系 统 提 供 的 一 组 <font color=orange>name=value</font>  形 式 的 变 量，不 同 的 环 境 变 量 有 不 同 的 用 户，通 常 有 全 局 属 性。
## 常 见 环 境 变 量
**PATH**：Linux 系 统 的 指 定 命 令 的 搜 索 路 径。

`echo $PATH`
提 取 PATH 的 环 境 变 量。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2e72e11302b145e4bf433ec1a209ef0e.png)
***
如 下 图 不 能 直 接 使 用 mytest 是 因 为 当 前 可 执 行 程 序 没 有 在 系 统 的 环 境 变 量 里，无 法 直 接 使 用。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6c9501d975ce4fd0b8b3a62fb020bf3b.png)
***
<font color=green>添 加 环 境 变 量</font>
1. 使 用 `pwd` 和 `ls` 找 到 可 执 行 程 序 的 路 径。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b3e3ff4bbd5d4839a5d88fe7ef21e427.png)

2. 将 pwd 下 面 的 路 径 复 制，鼠 标 右 击 选 择 复 制。如 果 没 有 弹 出 式 菜 单 可 以 在 文 章 后 面 找 到。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/258d3ab6eb2b45c78cb6ae6f975618e3.png)

3. 输 入 `PATH=路 径` 会 直 接 覆 盖 掉 原 来 的 PATH 路 径，导 致 指 令 无 法 使 用。可 以 输 入 `PATH=$PATH:路 径` 来 新 增 PATH 路 径。注 意 等 号 两 边 不 能 有 空 格，否 则 会 报 错。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/04055b50cded43eaa5f0ecbe47a989fd.png)
4. 添 加 完 成 后，输 入 `mytest` 即 可 正 常 运 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ace748162a374b54ac1ec71ce82632db.png)
***
<font color=blue>打 开 弹 出 型 菜 单</font>
1. 在 状 态 栏 点 击 `工 具`，找 到 最 下 面 的 `选 项`。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4cdf600f50244b37b8aca5af2e200aa2.png)
2. 点 击 `终 端`，在 向 右 按 钮 的 后 面 选 择 `打 开 弹 出 式 菜 单` 即 可。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2d543050ca994e8c98189c1cb4e6a94c.png)
***
大 部 分 [指 令](https://blog.csdn.net/2301_78847073/article/details/144816581?spm=1001.2014.3001.5501) 不 用 `./` 是 因 为 指 令 存 储 在 `/usr/bin` 这 个 路 径 的 文 件 夹 中。而 `/usr/bin` 这 个 文 件 夹 在 环 境 变 量 中。
<font color=red>如 果 不 小 心 清 空 了 环 境 变 量，只 需 要 重 新 登 录 Xshell 即 可。</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d445596e271040d3bd2bf94bc20b4f8c.png)
***
**HOME**：指 定 用 户 的 主 工 作 目 录（即 用 户 登 陆 到 Linux 系 统 中 时 默 认 的 目 录)。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b0bf7abd8eff4a44ac932ff58b1f733b.png)
可 以 使 用 `cd $HOME` 进 入 目 录。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2e921249e5ea41d595de9004dbe948fc.png)
**SHELL**：当 前 Shell，它 的 值 通 常 是 /bin/bash。这 个 路 径 保 存 着 当 前 Shell 的 可 执 行 程 序。
`echo`
输 出 环 境 变 量。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/73ae62e5597e42b0b7469267ef57f1e8.png)

`env`
查 询 环 境 变 量。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/52ba485da1bf48798df248f4263ccd19.png)
***
`getenv` 
用 于 获 取 环 境 变 量 的 值
`man getenv`
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4059aba1c059442cac18b068e0d6747d.png)
<font color=green>输 出 环 境 变 量</font>
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4163802a54a8445db51f1853e4ea2ff8.png)
## 环 境 变 量 的 组 织 方 式
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/56f9a81cfeef4dac849964d7725590e7.png)
每 个 程 序 都 会 收 到 一 张 环 境 表，环 境 表 是 一 个 字 符 指 针 数 组 ，每 个 指 针 指 向 一 个 以 ’\0’ 结 尾 的 环 境 字 符 串。
## 命 令 行 参 数
```
int main(int argc,char* argv[])
{
}
```
**argc**：表 示 命 令 行 参 数 的 数 量，至 少 为 1（因 为 第 一 个 参 数 默 认 是 程 序 自 身 的 名 称）。

**argv**：是 一 个 字 符 串 数 组，存 储 所 有 命 令 行 参 数。
argv[0] 通 常 是 程 序 的 名 称 或 路 径
argv[1] 及 以 后 是 用 户 输 入 的 实 际 参 数
***
**示 例 1**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/df2261fafe964be287bede957e47f17e.png)
循 环 判 断 条 件 中 可 以 将 argc 换 成 argv[i]，因 为 访 问 对 应 的 指 针 数 组 时，指 向 具 体 的 地 址，如 果 遍 历 到 NULL，条 件 不 满 足，退 出 for 循 环。
***
**示 例 2**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/08ec35d2db644e90ad49208a2b345c3f.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/276cb16c7d4f4cffb1155ae146f817b9.png)
**示 例 3**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c433354884d04435951ef15289d53e57.png)
***
<font color=blue>总 结</font>
命 令 行 参 数 为 指 令、工 具、软 件 等 提 供 命 令 行 选 项 的 支 持。为了 让 程 序 运 行 时 有 不 同 的 功 能。
***
## 2 张 表
代 码 总 共 有 2 张 表，1 个 是 命 令 行 参 数 表，另 1 个 是 环 境 变 量表，这 两 张 表 由 系 统 维 护。
**方 法 1**
可 以 使 用 命 令 行 参 数 输 出 环 境 变 量 表。
```
int main(int argc,char* argv[],char *env[])
{
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c639089a66b74c9dbcda8f436166486a.png)
***
**方 法 2**
`environ`
environ 是 一 个 全 局 变 量，用 于 访 问 当 前 进 程 的 所 有 环 境 变 量。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/73deaf75b97f4eec81173bbbdf6c3688.png)
***
<font color=orange>程 序 运 行 之 后 会 变 成 进 程，它 是 bash 进 程 的 子 进 程。运 行 的 进 程 都 是 子 进 程，bash 本 身 在 启 动 的 时 候，会 从 操 作 系 统 的 配 置 文 件 中 读 取 环 境 变 量 信 息。子 进 程 会 继 承 父 进 程 的 环 境 变 量。</font>

***
## 本 地 变 量
命 令 行 中 定 义 的 变 量 为 本 地 变 量。可 以 通 过 echo 查 到，本 地 变 量 不 是 环 境 变 量。本 地 变 量 只 会 在 本 Bash 内 部 有 效，不 会 被 继 承。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ce5b78a7fc3b434e98561e661a4897ff.png)
`export`
将 变 量 添 加 到 环 境 变 量 中。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e685110dc1984c78ab21c7ec115e13b5.png)
`unset`
删 除 本 地 变 量 和 环 境 变 量。
可 以 删 除 本 地 变 量，然 后 使 用 echo 验 证 是 否 成 功 删 除。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/d68065ebc136453b98149f5dff62c08e.png)
`set`
可 以 查 到 系 统 内 所 有 的 变 量，包 括 本 地 变 量 和 环 境 变 量。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a459e9f3cdb44d499b977ca645c2e7de.png)
***
## 命 令
### 内 置 命 令
1. **执 行 方 式**：由 Shell 直 接 调 用 内 部 函 数 实 现，不 创 建 子 进 程。bash 不 创 建 子 进 程，而 是 由 自 己 亲 自 执 行。类 似 于 bash 调 用 了 自 己 写 的，或 者 系 统 提 供 的 函 数。
2. **影 响 范 围**：操 作 直 接 作 用 于 当 前 Shell 环境（如 修 改 Shell 变量、工 作 目 录）。
3. **典 型 命 令**：cd（切 换 目 录，需 改 当 前 Shell 状 态）、set（配 置  Shell 选 项）、export（导 出 环 境 变 量 到 当 前 Shell 环 境）、echo（部 分 Shell 中 是 内 置）等。
### 常 规 命 令
1. **执 行 方 式**：Shell 会 先 fork 子 进 程，再 通 过 exec 加 载 外 部 程 序（如 /bin/ls、/usr/bin/cat）运 行，子 进 程 独 立 于 父 Shell。通 过 创 建 子 进 程 来 完 成 的。
2. **影 响 范 围**：仅 改 变 子 进 程 环 境，不 影 响 父 Shell（如 子 进 程 里 export 变 量，父 Shell 看 不 到）。
3. **典 型 命 令**：ls、cat、gcc、系 统 工 具 等（存 在 于 磁 盘 的 可 执 行 文 件）。
***
# 程 序 地 址 空 间
## 空 间 布 局 图 
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ca1dbd2aac7943c2be799cf96c1c9691.png)
***
## 验 证
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
int g_val_1;    // 未初始化变量
int g_val_2 = 100;    // 已初始化变量
int main()
{
    printf("代码区      :%p\n",main);
    const char *str = "hello world";
    printf("只读常量区  :%p\n",str);
    printf("未初始化常量:%p\n",&g_val_1);
    printf("已初始化常量:%p\n",&g_val_2);
    char *men = (char*)malloc(100);
    printf("堆区        :%p\n",men);
    printf("栈区        :%p\n",&str);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/14bc29a6fcf64a3c816d4e7e204d0a2d.png)
***
## 栈 区
`栈 区 向 地 址 减 小 的 方 向 增 长`

先 定 义 的 变 量 先 入 栈，后 定 义 的 变 量 后 入 栈。
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
int main()
{
    const char *str = "hello world";
    char* mem = (char*)malloc(100);
    printf("栈区:%p\n",&str);
    printf("栈区:%p\n",&mem);
    int a;
    int b;
    int c;
    printf("栈区:%p\n",&a);
    printf("栈区:%p\n",&b);
    printf("栈区:%p\n",&c);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0fa09b8698524db88f3027d69dcb83cf.png)
***
## 堆 区
`堆 区 向 地 址 增 大 的 方 向 增 长。`
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
int main()
{
    char* mem1 = (char*)malloc(100);
    char* mem2 = (char*)malloc(100);
    char* mem3 = (char*)malloc(100);
    printf("堆区:%p\n",&mem1);
    printf("堆区:%p\n",&mem2);
    printf("堆区:%p\n",&mem3);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/bb2e442179884daf8153ae5504962ba7.png)
***
## 全 局 数 据 区
1. 未 初 始 化 全 局 变 量 和 已 初 始 化 全 局 变 量 这 2 个 区 域 的 统 称 为全 局 数 据 区。
2. static 修 饰 的 变 量 在 编 译 的 时 候 被 编 译 到 全 局 数 据 区。
***
## 线 性 地 址 或 者 虚 拟 地 址
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<string.h>
int g_val = 100;
int main()
{
    pid_t id = fork();
    if(id == 0)
    {
        int cnt = 5;
        //子进程
        while(1)
        {
            printf("I am child,pid:%d,ppid:%d,g_val:%d,&g_val:%p\n",getpid(),getppid(),g_val,&g_val);
            sleep(1);
            if(cnt)
            {
                cnt--;
            }
            else 
            {
                g_val = 200;
                printf("子进程change g_val:100->200\n");
                cnt--;
            }
        }
    }
    else 
    {
        //父进程
        while(1)
        {
            printf("I am father,pid:%d,ppid:%d,g_val:%d,&g_val:%p\n",getpid(),getppid(),g_val,&g_val);
            sleep(1);
        }   
    }
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/33bcf1d081324d05829d553f5814055d.png)
1. 同 一 个 变 量，同 一 个 地 址，同 时 读 取，读 到 了 不 同 的 内 容。
如 果 变 量 的 地 址 是 物 理 地 址，不 可 能 存 在 上 面 的 现 象。这 里 发 生 了 写 时 拷 贝，这 个 地 址 是 线 性 地 址 或 者 虚 拟 地 址。
2. C++ 中 使 用 的 指 针，指 针 里 面 的 地 址 全 部 都 不 是 物 理 地 址。物 理 地 址，用 户 一 概 看 不 到，由 OS 统 一 管 理。OS 必 须 负 责 将 虚 拟 地 址 转 化 成 物 理 地 址。
# 地 址 空 间
## 进 程 地 址 空 间
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a5c1a621f7be4981a5cafd594a0099a1.png)
1. 如 果 父 子 进 程 的 页 表 相 同，则 代 码 和 数 据 可 以 共 享。
2. 如 果 子 进 程 的 物 理 地 址 改 变，即 子 进 程 指 向 新 的 空 间，父 进 程 还 是 原 来 的 空 间。先 经 过 写 时 拷 贝，它 是 由 操 作 系 统 自 动 完 成 的。本 质 是 重 新 开 辟 空 间，左 侧 的 虚 拟 地 址 是 0 感 知 的，不 会 关 心 和 影 响 它。
3. 同 一 个 变 量，地 址 相 同，其 实 是 虚 拟 地 址 相 同，内 容 不 同 其 实 是 被 映 射 到 了 不 同 的 物 理 地 址！
## 地 址 空 间
进 程 正 在 运 行，CPU 通 过 访 问 不 同 的 地 址 总 线 来 访 问 不 同 的 物 理 内 存。
在 32 位 计 算 机 中，有 32 位 的 地 址 和 数 据 总 线。
CPU 和 内 存 之 间 的 线 为 系 统 总 线。
内 存 和 外 设 之 间 的 线 为 IO 总 线。
CPU 和 内 存 都 有 短 暂 的 数 据 存 储 能 力。

## 计 算 机 底 层 数 据 交 互
1. **二 进 制 的 物 理 载 体 是 高 低 电 平**：计 算 机 所 有 数 据（地 址、指 令、数 据 本 身）的 底 层 均 为 二 进 制（0/1），而 二 进 制 在 硬 件 中 通 过 统 一 标 准 的 高 低 电 平 实 现（如 TTL 电 平 中 5V 代 表 1、0 V 代 表 0），这 是 不 同 设 备（CPU、内 存 等）能 “互 通” 的 基 础。
2. **CPU 与 内 存 的 交 互 是 “电 平 信 号 的 传 递 与 解 码”**：CPU 不 会 向 内 存 “充 电”，而 是 先 生 成 目 标 物 理 地 址（二 进 制），再 将 地 址 的 每 一 位（0/1）转 为 高 低 电 平，通 过 地 址 总 线 并 行 传 输 给 内 存；内 存 的 地 址 译 码 器 解 读 这 些 电 平，最 终 定 位 到 需 访 问 的 物 理 存 储 单 元。
3. **设 备 间 数 据 拷 贝 是 “电 平 信 号 的 转 换 与 存 储”**：并 非 直 接 “充 放 电”，而 是 发 送 方 先 将 自 身 存 储 的 0/1 转 为 高 低 电 平，经 总 线 传 递 后，接 收 方 将 电 平 信 号 转 换 为 自 身 的 存 储 状 态，完 成 数 据 传 递。
4. **完 整 逻 辑 链**：二 进 制 → 高 低 电 平（信 号 载 体）→ 总 线 传 输 → 设 备 解 读 / 转 换 电 平 → 定 位 地 址 或 存 储 数 据，最 终 实 现 CPU  对 内 存 的 访 问 及 设 备 间 的 数 据 交 互。