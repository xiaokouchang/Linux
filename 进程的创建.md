1. # 一、进 程 的 创 建
  ## 1、fork 函 数 初 识
  在 linux 中 fork 函 数 是 非 常 重 要 的 函 数，它 从 已 存 在 进 程 中 创 建 一 个 新 进 程。新 进 程 为 子 进 程，而 原 进 程 为 父 进 程。
  进 程 调 用 fork，当 控 制 转 移 到 内 核 中 的 fork 代 码 后，内 核 做：
  1. 分 配 新 的 内 存 块 和 内 核 数 据 结 构 给 子 进 程
  2. 将 父 进 程 部 分 数 据 结 构 内 容 拷 贝 至 子 进 程，页 表 代 码 和 数 据 可 以 是 完 全 一 样 的。
  3. 添 加 子 进 程 到 系 统 进 程 列 表 当 中
  4. fork 返 回，开 始 调 度 器 调 度
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0a96941c4e3f43b790991ad9e0259dbd.png)
  ```javascript
  #include<stdio.h>
  #include<unistd.h>
  #include<stdlib.h>
  int main()
  {
      printf("pid:%d Before!\n",getpid());
      fork();
      printf("pid:%d After!\n",getpid());
      return 0;
  }
  ```
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/520e01a1206645b5ae00e16f9d50e2cb.png)
  fork 之 前 父 进 程 独 立 执 行，fork 之 后，父 子 两 个 执 行 流 分 别 执 行。

  ==注 意==
  fork 之 后，谁 先 执 行 完 全 由 调 度 器 决 定。
  ***
  ## fork 函 数 返 回 值
  子 进 程 返 回 0，父 进 程 返 回 的 是 子 进 程 的 pid。
  ***
  ## 写 时 拷 贝
  父 子 代 码 共 享，父 子 再 不 写 入 时，数 据 也 是 共 享 的，当 任 意 一 方 试 图 写 入，便 以 写 时 拷 贝 的 方 式 各 自 一 份 副 本。

  <font color=orange>写 时 拷 贝 本 质 是 写 的 时 候 再 用，是 一 种 延 时 申 请，按 需 申 请。</font>

  具 体 见 下 图:
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/de62b0758ccb4217b91e82096d3edd13.png)
  无 论 是 父 进 程 还 是 子 进 程，如 果 想 要 写 入，会 将 父 进 程 中 可 写 的 部 分 改 成 只 读，子 进 程 继 承 时 也 是 只 读 状 态，暂 时 是 只 读 状 态。针 对 这 种 情 况，操 作 系 统 不 做 异 常 处 理，如 果 想 要 写 入 数 据，会 将 页 表 对 应 的 区 域 重 新 映 射，然 后 进 行 写 时 拷 贝，这 样 就 能 访 问 原 来 可 写 的 区 域。
  ***
  ## 创 建 多 个 进 程
  ```javascript
  #include<unistd.h>
  #include<stdlib.h>
  #define N 5
  void RunChild()
  {
      int cnt = 5;
      while(cnt)
      {
          printf("I am child:%d,ppid:%d\n",getpid(),getppid());
          sleep(1);
          cnt--;
      }
  }
  int main()
  {
      for(int i = 0;i<N;i++)
      {
          pid_t id = fork();
          if(id==0)
          {
              //子进程
              RunChild();
              exit(0);//终止子进程
          }
      }
      sleep(1000);
      return 0;
  }
  ```
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6afab325b78b44509e2f7242ee837cf4.png)
  5 次 循 环 结 束 后，父 进 程 没 有 结 束，子 进 程 终 止 成 为 僵 尸 进 程。父 子 进 程 谁 先 运 行 由 调 度 器 决 定。
  # 进 程 终 止
  ## 进 程 退 出 场 景
  1. 代 码 运 行 完 毕，结 果 正 确
  2. 代 码 运 行 完 毕，结 果 不 正 确
  3. 代 码 异 常 终 止

  <font color=red>结 果 是 否 正 确 采 用 进 程 的 退 出 码 来 进 行 判 定。</font>
  ## 进 程 常 见 退 出 方 法
  <font color=orange>成 功 只 有 1 种 可 能，但 失 败 有 多 个 理 由。</font>

  （1）**正 常 终 止（可 以 通 过 `echo $?` 查 看 进 程 退 出 码）**：

  `echo $?`
  表 示 最 近 一 次 进 程 退 出 时 的 退 出 码。可 以 通 过 观 察 退 出 码 来 判 断 进 程 是 否 正 常 结 束。

  ***
  1. 从 main 返 回

  在 c 语 言 中，程 序 返 回 0 中 的 0 表 示 进 程 的 退 出 码，表 征 进 程 的 运 行 结 果 是 否 正 确，0->success。main 函 数 的 返 回 值 的 本 质 表 示 进 程 运 行 完 成 时 是 否 是 正 确 的 结 果，如 果 不 是，可 以 使 用 不 同 的 数 字 表 示 不 同 的 出 错 原 因。

  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c250be631d4947ba80ec8ed3872f6b21.png)
  进 程 中 父 进 程 会 关 心 程 序 的 运 行 情 况，用 户 可 以 根 据 错 误 码 来 找 出 程 序 中 的 错 误。
  ***
  **可 以 改 变 return 的 返 回 值**
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ce1a54ac879041db925c0d60d45ee5e4.png)
  如 上 图 所 示，第 二 次 调 用 `echo $?` 返 回 值 成 为 0。当 第 2 次 输 出 时，程 序 变 成 了 `echo` 命 令，`echo` 上 次 执 行 是 正 确 的，所 以 退 出 码 为 0。
  ***
  `strerror`
  将 错 误 码 转 换 成 错 误 码 描 述。
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/15d8f5709a3f4c45b1ad0ab008556f8a.png)
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0fe565f99c4549afab3e0ca865fd2a7d.png)
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7d2e1fb050db44a097bb1cb62d002b69.png)
  ***
  **示 例 1**
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9a5441e631734a938908eb1e1e9463e5.png)

  <font color=blue>系 统 提 供 的 错 误 码 和 错 误 码 描 述 是 有 对 应 关 系 的。错 误 码 用 来 表 征 错 误 原 因，错 误 码 描 述 展 现 更 详 细 的 错 误 信 息。</font>
  ***
  **示 例 2**
  可 以 自 己 定 义 错 误 码。
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/df28712db80a4b09912443d342c223ed.png)
  ***
  `errno`
  最 近 一 次 的 错 误 码。
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/cbb8777612904a82acbfeb1efc385796.png)
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4918ba8a8f3f4a9293f67760c9ab5fb3.png)
  **示 例**
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aa022f2f8b7b43c1b3ee306627bf0cda.png)
  ## 代 码 异 常
  本 质 可 能 就 是 代 码 没 有 跑 完。进 程 的 退 出 码 无 意 义，不 关 心 退 出 码 了。进 程 出 现 了 异 常，本 质 是 进 程 收 到 了 对 应 的 信 号。
  ```javascript
  #include<stdio.h>
  #include<unistd.h>
  #include<stdlib.h>
  #include<string.h>
  #include<errno.h>
  int main()
  {
      int* p = NULL;
      *p=100;
      return 0;
  }
  ```
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f0cd32e29de14e5fb61d905c2272dab3.png)
  访 问 野 指 针，进 程 抛 出 异 常 显 示 段 错 误，对 应 第 11 号。

  **验 证**
  ```javascript
  #include<stdio.h>
  #include<unistd.h>
  #include<stdlib.h>
  #include<string.h>
  #include<errno.h>
  int main()
  {
      while(1)
      {
          printf("Hello world,pid:%d\n",getpid());
          sleep(1);
      }
      return 0;
  }
  ```
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/845f21b3761f4cfcbc61045ec4807855.png)
  第 11 个 信 号 是 进 程 出 现 了 段 错 误。
  ## echo
  终 止 程 序 并 返 回 程 序 的 退 出 码 和 return 的 效 果 类 似。

  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3ba68d855e9b4cfc9d758f3d87b69d49.png)
  ## exit 和 return 的 区 别
  **return**
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/103bd43a9cd94ab1a900759eb6cd28b8.png)
  **exit**
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/aa4a7aade9bd43c8b6cd0e724c274793.png)

  exit 在 任 意 地 方 被 调 用，都 表 示 调 用 进 程 直 接 退 出，return 只 表 示 当 前 函 数 返 回，没 有 退 出 进 程。
  ## _exit
  终 止 进 程。
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/28ffbff70ce44fe6855431437716520f.png)
  ## exit 和 _exit 的 区 别
  **exit**
  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/0788c2a37fe24c05a6f89b748689c3e0.gif#pic_center)

  **_exit**

  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/633db53644fb4c6cb6c4b5804dfb0448.gif#pic_center)
  exit 在 结 束 之 后 还 做 了 以 下 工 作：
  1. 执 行 用 户 通 过 atexit 或 on_exit 定 义 的 清 理 函 数。
  2. 关 闭 所 有 打 开 的 流，所 有 的 缓 存 数 据 均 被 写 入。
  3. 调 用 _exit。

  ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/800014dda2144646af49b40982f491ac.png)

  <font color=green>exit 是 库 函 数，_exit 是 系 统 调 用。</font>
  printf 函 数 先 把 数 据 写 入 缓 冲 区 中，合 适 的 时 候 进 行 刷 新。
  这 个 缓 冲 区 绝 对 不 在 内 核 中。如 上 图，如 果 缓 冲 区 在 内 核 中，exit 和 _exit 都 会 刷 新，但 实 际 _exit 没 有 刷 新 缓 冲 区。

  # 进 程 等 待
  ## 必 要 性
  1. 子 进 程 退 出，父 进 程 如 果 不 管 不 顾，就 可 能 造 成 ‘僵 尸 进 程’ 的 问 题，进 而 造 成 内 存 泄 漏。
  2. 进 程 一 旦 变 成 僵 尸 状 态，那 就 刀 枪 不 入，“杀 人 不 眨 眼” 的 kill -9 也 无 能 为 力，因 为 谁 也 没 有 办 法 杀 死 一 个 已 经 死 去 的 进 程。
  3. 父 进 程 派 给 子 进 程 的 任 务 完 成 的 如 何，我 们 需 要 知 道。如 子 进 程 运 行 完 成，结 果 对 还 是 不 对，或 者 是 否 正 常 退 出。
  父 进 程 通 过 进 程 等 待 的 方 式，回 收 子 进 程 资 源，获 取 子 进 程 退 出 信 息。

  