# 一、进 程 程 序 替 换
## 定 义
用 fork 创 建 子 进 程 后 执 行 的 是 和 父 进 程 相 同 的 程 序（但 有 可 能 执 行 不 同 的 代 码 分 支），子 进 程 往 往 要 调 用 一 种 exec 函 数 以 执 行 另 一 个 程 序。当 进 程 调 用 一 种 exec 函 数 时，该 进 程 的 用 户 空 间 代 码 和 数 据 完 全 被 新 程 序 替 换，从 新 程 序 的 启 动 例 程 开 始 执 行。调 用 exec 并 不 创 建 新 进 程，所 以 调 用 exec 前 后 该 进 程 的 id 并 未 改 变。
## execl 系 列
执 行 对 应 的 文 件。execl 是 一 个 可 变 参 数，可 以 传 不 同 的 选 项。 
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f0f92caddb3b45899de2501295f46c4e.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/edd366df5f5b46659528f8f3db60b074.png)

## 现 象
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
int main()
{
    printf("before:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
    execl("/usr/bin/ls","ls","-a","-l",NULL);//必须以NULL结尾
    printf("after:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/13b8a077b5bb4bb086a6f00998aa3dc1.png)
这 种 现 象 叫 做 程 序 替 换。程 序 替 换 成 功 之 后 的 代 码 不 会 被 执 行。exec 系 列 的 函 数 只 有 失 败 返 回 值 没 有 成 功 返 回 值。
***
## 原 理
程 序 替 换 指 的 是 通 过 系 统 调 用，用 一 个 新 的 程 序 替 换 当 前 进 程 的 代 码、数 据、堆 栈 等 内 容，而 进 程 的 PID（进 程 ID）保 持 不 变 的 操 作。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/30ce2ca5411f4b07a02a82098d55cc73.png)
**父 子 进 程**
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
int main()
{
    pid_t id = fork();
    if(id == 0)
    {
        //child
        printf("before:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        sleep(5);
        execl("/usr/bin/ls","ls","-a","-l",NULL);//必须以NULL结尾
        printf("after:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        exit(0);
    }
    pid_t ret = waitpid(id,NULL,0);
    if(ret>0)
    {
        printf("wait success,father pid:%d,ret pid:%d\n",getpid(),ret);
    }
    sleep(5);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e035316fe5a348c4a25d5cdeef8719cc.png)
**结 论**
1. <font color=orange>子 进 程 的 程 序 替 换 并 不 会 影 响 父 进 程 的 代 码，是 因 为 写 时 拷 贝 以 及 进 程 之 间 的 独 立 性。</font>替 换 数 据 和 代 码 是 写 时 拷 贝，如 果 要 写 入 的 区 域 是 只 读 的 并 且 代 码 区 是 父 子 进 程 共 享 的，此 时 不 能 直 接 替 换，应 进 行 写 时 拷 贝。

2. `程 序 替 换 没 有 创 建 新 进 程，只 进 行 进 程 的 程 序 代 码 和 数 据 的 替 换 工 作。`
3. 替 换 之 后 父 子 关 系 不 发 生 改 变，父 进 程 等 待 的 是 子 进 程 的PCB，
***
cpu 知 道 程 序 的 入 口 地 址 是 因 为 linux 中 形 成 可 执 行 程 序 是 有 格 式 的，为 ELF，有 可 执 行 程 序 的 表 头，可 执 行 程 序 的 入 口 地 址 就 在 表 中。
## 程 序 替 换 的 接 口
### 7 个 接 口 函 数
linux 总 共 有 7 个 接 口 函 数，在 3 号 手 册 中 有 6 个，2 号 手 册 中 有 1 个。
**3 号 手 册**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/335b50247b0c4cdf98b388e0380d777b.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2177b7bd10584ae0a9fb86135063d143.png)
**2 号 手 册**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/29edc3c796734dba866943fba416b33f.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/711cb5fa6acc4a808ba5f36ed2aaabd7.png)
### execl
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/3179e48169f749ce89a608eb627f91eb.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/09b88a9053844ed5886d0923c668f6f7.png)


exec 系 列 的 所 有 函 数 名 开 头 都 是 exec，execl 中 的 l 可 以 理 解 为`list`，execl 中 可 以 使 用 可 变 参 数，即 一 个 一 个 传 参。命 令 行 中 如 何 写 的，传 参 时 就 怎 样 传，只 是 将 空 格 换 成 逗 号，然 后 最 后 添 加 `NULL` 即 可。
### execlp
execlp 中 p 指 的 是 PATH，即 execlp 自 己 会 在 默 认 的 PATH 环 境 变 量 中 查 找，使 用 时 可 以 添 加 路 径 也 可 以 不 添 加 路 径。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/42ef69f9d0f14809b27900f5afc9a276.png)
```javascript
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>

int main()
{
    pid_t id = fork();
    if(id == 0)
    {
        //child
        printf("before:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        sleep(5);
        //execl("/usr/bin/ls","ls","-a","-l",NULL);//必须以NULL结尾
        //execlp("/usr/bin/ls","ls","-a","-l",NULL);//必须以NULL结尾
        execlp("ls","ls","-a","-l",NULL);//必须以NULL结尾
        printf("after:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        exit(0);
    }
    pid_t ret = waitpid(id,NULL,0);
    if(ret>0)
    {
        printf("wait success,father pid:%d,ret pid:%d\n",getpid(),ret);
    }
    sleep(5);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/b5a8b51f857946fab2f830538eabd9c2.png)
***
### execv
v 指 的 是 vector 即 数 组 或 者 顺 序 表。第 1 个 参 数 是 路 径。第 2 个 参 数 的 类 型 是 字 符 串 指 针 数 组，将 选 项 和 指 令 当 做 字 符 串 存 储。const 的 意 思 是 指 针 本 身 不 能 被 修 改。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7c65c53a81324892baa5947ec82d696b.png)
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>

int main()
{
    pid_t id = fork();
    if(id == 0)
    {
        //child
        printf("before:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        sleep(5);
        //execl("/usr/bin/ls","ls","-a","-l",NULL);//必须以NULL结尾
        //execlp("/usr/bin/ls","ls","-a","-l",NULL);//必须以NULL结尾
        //execlp("ls","ls","-a","-l",NULL);//必须以NULL结尾
        char *const myargv[] = {"ls","-a","-l",NULL};
        execv("/usr/bin/ls",myargv);
        printf("after:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        exit(0);
    }
    pid_t ret = waitpid(id,NULL,0);
    if(ret>0)
    {
        printf("wait success,father pid:%d,ret pid:%d\n",getpid(),ret);
    }
    sleep(5);
    return 0;
}
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ded907ec596a4a15a79997a6e989546f.png)
<font color=green>linux 当 中 所 有 的 进 程 一 定 是 别 人 的 子 进 程，在 命 令 行 当 中，所 有 的 进 程 都 是 bash 的 子 进 程。</font>
exec 系 列 的 函 数 承 载 着 加 载 器 的 效 果，是 代 码 级 别 的 加 载 器，将 可 执 行 程 序 导 入 内 存 中。
### execvp
`execvp` 则 直 接 使 用 可 执 行 程 序 的 名 字 即 可。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/f01ccd697dd54d968be3191ffceee4f5.png)
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/25d023db4b5f47c99aa4e846a70ed44a.png)
实 际 是 将 myargv 的 参 数 传 递 给 ls。
### execle
execle 中 的 e 表 示 环 境 变 量，第 1 个 参 数 为 文 件 的 路 径。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/93ce2a8bdfdc407f8257e5c90e19ef50.png)
***
exec* 能 够 执 行 系 统 命 令，可 以 执 行 自 己 的 命 令。
**mytest.c**
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
int main()
{
    pid_t id = fork();
    if(id == 0)
    {
        //child
        printf("before:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        execl("./mytestcpp","mytestcpp",NULL);
        printf("after:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        exit(0);
    }
    pid_t ret = waitpid(id,NULL,0);
    if(ret>0)
    {
        printf("wait success,father pid:%d,ret pid:%d\n",getpid(),ret);
    }
    sleep(5);
    return 0;
}
```
**mytest.cpp**
```javascript
#include<iostream>

using namespace std;
int main()
{
    cout << "hello world" << endl; 
    return 0;
}
```
**makefile**
```javascript
.PHONY:all
all:mytestc mytestcpp
mytestc:mytest.c
	gcc mytest.c -o mytestc -std=c99
mytestcpp:mytest.cpp
	g++ mytest.cpp -o mytestcpp -std=c++11
.PHONY:clean
clean:
	rm -rf mytestc mytestcpp 
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/30e4130e5cca47778d7aa06ccd799c39.png)
***
以 `.sh` 结 尾 的 文 件 为 shell 脚 本。脚 本 语 言 都 以 `#!` 作 为 开 头。后 面 是 脚 本 语 言 的 解 释 器。脚 本 语 言 就 是 文 本 文 件，bash 可 以 对 文 本 文 件 边 读 取 边 执 行。
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a33b8137af0a4016bf9224d867a72347.png)
**test.sh**
```javascript
#!/usr/bin/bash 
echo "hello world"
echo "hello world"
echo "hello world"
echo "hello world"
echo "hello world"
echo "hello world"

ls -al
```
**解 释 器 + 脚 本 文 件 名 执 行**
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a1ae15865d27489d932fe6a0d3876c20.png)
<font color=write>execl 调 用 脚 本 文 件</font>
**mytest.c**
```javascript
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<sys/types.h>
#include<sys/wait.h>
int main()
{
    pid_t id = fork();
    if(id == 0)
    {
        //child
        printf("before:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        execl("/usr/bin/bash","bash","test.sh",NULL);
        printf("after:I am a process,pid:%d,ppid:%d\n",getpid(),getppid());
        exit(0);
    }
    pid_t ret = waitpid(id,NULL,0);
    if(ret>0)
    {
        printf("wait success,father pid:%d,ret pid:%d\n",getpid(),ret);
    }
    sleep(5);
    return 0;
}
```
**test.sh**
```javascript
#!/usr/bin/bash 
function myfun()
{
    cnt=1
    while [ $cnt -le 10 ]
    do 
        echo "hello $cnt"
        let cnt++
    done
}
echo "hello world"
echo "hello world"
echo "hello world"
echo "hello world"
echo "hello world"
echo "hello world"

ls -al
```
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/7cbad40b69cf4a6785e63ecd47193f51.png)